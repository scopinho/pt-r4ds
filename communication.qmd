# Comunicação {#sec-communication}

```{r}
#| echo: false
#| results: asis

source("_common.R")

```

## Introdução

No @sec-exploratory-data-analysis, você aprendeu como usar gráficos como ferramentas para *exploração*.
Ao fazer gráficos exploratórios, você sabe --- mesmo antes de olhar --- quais variáveis ​​o gráfico exibirá.
Você criou cada gráfico com um propósito, pôde examiná-lo rapidamente e depois passar para o próximo gráfico.
No decorrer da maior parte das análises, você produzirá dezenas ou centenas de gráficos, a maioria dos quais será imediatamente descartada.

Agora que você entende seus dados, você precisa *comunicar* sua compreensão a outras pessoas.
Seu público provavelmente não compartilhará seu conhecimento prévio e não conhecerá profundamente os dados.
Para ajudar outros a construirem rapidamente um bom modelo mental dos dados, você precisará investir um esforço considerável para tornar seus gráficos o mais autoexplicativos possível.
Neste capítulo, você aprenderá algumas das ferramentas que o pacote ggplot2 fornece para fazer isso.

Este capítulo se concentra nas ferramentas necessárias para criar bons gráficos.
Presumimos que você sabe o que quer e só precisa saber como fazer.
Por esse motivo, é altamente recomendável combinar este capítulo com um bom livro de visualização geral.
Gostamos particularmente do livro [The Truthful Art](https://www.amazon.com/gp/product/0321934075/), de Albert Cairo.
Ele não ensina a mecânica de criação de visualizações, mas concentra-se no que você precisa pensar para criar gráficos eficazes.

### Pré-requisitos

Neste capítulo, focaremos mais uma vez no ggplot2.
Também usaremos um pouco do pacote dplyr para transformação de dados, **scales** para substituir quebras, rótulos, transformações e paletas padrão, e alguns pacotes de extensão ggplot2, incluindo **ggrepel** ([https://ggrepel.slowkow.com](https://ggrepel.slowkow.com/)) de Kamil Slowikowski e o **patchwork** ([https://patchwork.data-imaginist.com](https://patchwork.data-imaginist .com/)) de Thomas Lin Pedersen.
Usaremos também o pacote *dados* e seus conjuntos de dados *milhas*, *predisentes_eua* e *diamante*.
Não se esqueça que você precisará instalar esses pacotes com `install.packages()` se ainda não os tiver.

```{r}
#| label: setup
#| message: false

library(tidyverse)
library(scales)
library(ggrepel)
library(patchwork)
library(dados)
```

## Rótulos

O lugar mais fácil para começar a transformar um gráfico exploratório em um gráfico expositivo é com bons rótulos (*labels*).
Você adiciona rótulos com a função `labs()`.

```{r}
#| message: false
#| fig-alt: |
#|   Gráfico de dispersão de uso de combustível em rodovias versus cilindradas dos carros, onde
#|   os pontos são coloridos de acordo com a classe do carro. Uma curva suave seguindo
#|   a trajetória da relação entre eficiência de combustível nas rodovias versus 
#|   as cilindradas dos carros está sobreposto. O eixo x é rotulado como "Cilindrada  
#|   do Motor (L)" e o eixo y é rotulado como "Consumo de combustível na rodovia (mpg)". 
#|   A legenda é rotulada como "Tipo de veículo". O gráfico é intitulado "Eficiência de combustível 
#|   geralmente diminui com o tamanho do motor". O subtítulo é "Carros de dois lugares
#|   (carros esportivos) são uma exceção devido ao seu peso leve" e  
#|    a legenda contém "Dados de fueleconomy.gov".

ggplot(milhas, aes(x = cilindrada, y = rodovia)) +
  geom_point(aes(color = classe)) +
  geom_smooth(se = FALSE) +
  labs(
    x = "Cilindrada do Motor (L)",
    y = "Economia de combustível na rodovia (mpg)",
    color = "Tipo de veículo",
    title = "Eficiência de combustível geralmente diminui com o tamanho do motor",
    subtitle = "Dois lugares (carros esportivos) são uma exceção devido ao seu peso leve",
    caption = "Dados de fueleconomy.gov"
  )
```

O objetivo do título (*title*) de um gráfico é resumir a descoberta principal.
Evite títulos que apenas descrevam o gráfico, por exemplo, "Um gráfico de dispersão da cilindrada do motor versus economia de combustível".

Se você precisar adicionar mais texto, existem dois outros argumentos de rótulos úteis: `subtitle` (subtítulo) adiciona detalhes em uma fonte menor abaixo do título e `caption` (legenda) adiciona texto no canto inferior direito do gráfico, geralmente usado para descrever a fonte dos dados.
Você também pode usar `labs()` para substituir os títulos dos eixos e das legendas.
Geralmente é uma boa ideia substituir nomes curtos de variáveis ​​por descrições mais detalhadas e incluir as unidades.

É possível usar equações matemáticas em vez de sequências de texto.
Basta trocar `""` por `quote()` e ler sobre as opções disponíveis em `?plotmath`:

```{r}
#| fig-asp: 1
#| out-width: "50%"
#| fig-width: 3
#| fig-alt: |
#|   Gráfico de dispersão com texto matemático nos rótulos dos eixos x e y. Rótulo do eixo X
#|   diz x_i, o rótulo do eixo y diz soma de x_i ao quadrado, para i de 1 a n.

df <- tibble(
  x = 1:10,
  y = cumsum(x^2)
)

ggplot(df, aes(x, y)) +
  geom_point() +
  labs(
    x = quote(x[i]),
    y = quote(sum(x[i] ^ 2, i == 1, n))
  )
```

### Exercícios

1. Crie um gráfico com os dados de economia de combustível (milhas) com rótulos personalizados de `title`, `subtitle`, `caption`, `x`, `y` e `color`.

2. Recrie o gráfico a seguir usando os dados de economia de combustível.
    Observe que as cores e os formatos dos pontos variam de acordo com o tipo de tração.

    ```{r}
    #| echo: false
    #| fig-alt: |
    #|   Gráfico de dispersão de eficiência de combustível em rodovias versus em cidades. Formas e
    #|   as cores dos pontos são determinadas pelo tipo de tração.

    ggplot(milhas, aes(x = cidade, y = rodovia, color = tracao, shape = tracao)) +
      geom_point() +
      labs(
        x = "Eficiência na cidade",
        y = "Eficiência na rodovia",
        shape = "Tipo de \ntração",
        color = "Tipo de\ntração"
      )
    ```

3.  Pegue um gráfico exploratório que você criou no último mês e adicione rótulos informativos para facilitar a compreensão de outras pessoas.

## Anotações

Além de rotular os principais componentes do seu gráfico, muitas vezes é útil rotular observações individuais ou grupos de observações.
A primeira ferramenta que você tem à sua disposição é `geom_text()`.
`geom_text()` é semelhante a `geom_point()`, mas tem uma estética adicional: `label`.
Isso torna possível adicionar rótulos textuais aos seus gráficos.

Existem duas fontes possíveis de rótulos para as observações.
Primeiro, você pode ter um arquivo que fornece estes rótulos.
No gráfico a seguir, retiramos os carros com maior cilindradas em cada tipo de tração e salvamos suas informações como um novo conjunto de dados `rotulos_info`.

```{r}
rotulos_info <- milhas |>
  group_by(tracao) |>
  arrange(desc(cilindrada)) |>
  slice_head(n = 1) |>
  mutate(
    tipo_tracao = case_when(
      tracao == "d" ~ "tração dianteira",
      tracao == "t" ~ "tração traseira",
      tracao == "4" ~ "4x4"
    )
  ) |>
  select(cilindrada, rodovia, cilindrada, tipo_tracao)

rotulos_info
```

Em seguida, usamos esse novo conjunto de dados para rotular diretamente os três grupos e substituir a legenda por rótulos colocados diretamente no gráfico.
Usando os argumentos `fontface` e `size` podemos personalizar a aparência dos rótulos de texto.
Eles são maiores que o restante do texto do gráfico e estão em negrito.
(`theme(legend.position = "none"`) desativa todas as legendas --- falaremos sobre isso mais tarde.

```{r}
#| fig-alt: |
#|   Gráfico de dispersão de eficiência de combustível nas rodovias versus cilindradas onde os pontos são coloridos
#|   por tipo de tração. Curvas suaves para cada tipo de tração são sobrepostas. 
#|   Os rótulos de texto identificam as curvas como tração dianteira, tração traseira e 4x4.

ggplot(milhas, aes(x = cilindrada, y = rodovia, color = tracao)) +
  geom_point(alpha = 0.3) +
  geom_smooth(se = FALSE) +
  geom_text(
    data = rotulos_info, 
    aes(x = cilindrada, y = rodovia, label = tipo_tracao),
    fontface = "bold", size = 5, hjust = "right", vjust = "bottom"
  ) +
  theme(legend.position = "none")
```

Observe o uso de `hjust` (justificação horizontal) e `vjust` (justificação vertical) para controlar o alinhamento do rótulo.

No entanto, o gráfico anotado que fizemos acima é difícil de ler porque os rótulos se sobrepõem entre si e com os pontos.
Podemos usar a função `geom_label_repel()` do pacote ggrepel para resolver esses dois problemas.
Este pacote ajustará automaticamente os rótulos para que não se sobreponham:

```{r}
#| fig-alt: |
#|   Gráfico de dispersão da eficiência de comsbutível nas rodovias versus cilindradas, onde 
#|   os pontos são coloridos de acordo com a classe de tração do carro. Alguns pontos são rotulados 
#|   com o nome do carro. Os rótulos são caixas com fundo branco e transparente 
#|   e posicionados de modo que não se sobreponham.

ggplot(milhas, aes(x = cilindrada, y = rodovia, color = tracao)) +
  geom_point(alpha = 0.3) +
  geom_smooth(se = FALSE) +
  geom_label_repel(
    data = rotulos_info, 
    aes(x = cilindrada, y = rodovia, label = tipo_tracao),
    fontface = "bold", size = 5, nudge_y = 2
  ) +
  theme(legend.position = "none")
```

Você também pode usar a mesma ideia para destacar certos pontos em um gráfico com `geom_text_repel()` do pacote ggrepel.
Observe outra técnica útil usada aqui: adicionamos uma segunda camada de pontos grandes e ocos para destacar ainda mais os pontos rotulados.

```{r}
#| fig-alt: |
#|   Gráfico de dispersão de eficiência de combustível nas rodovias versus as cilindradas dos carros. Pontos
#|   onde a eficiência do uso de combustível da rodovia está acima de 40 e também acima de 20 com tamanho do motor 
#|   acima de 5 são vermelhos, com um círculo vermelho vazio e rotulados com o nome do modelo 
#|   do carro.

potenciais_discrepantes <- milhas |>
  filter(rodovia > 40 | (rodovia > 20 & cilindrada > 5))
  
ggplot(milhas, aes(x = cilindrada, y = rodovia)) +
  geom_point() +
  geom_text_repel(data = potenciais_discrepantes, aes(label = modelo)) +
  geom_point(data = potenciais_discrepantes, color = "red") +
  geom_point(
    data = potenciais_discrepantes,
    color = "red", size = 3, shape = "circle open"
  )
```

Lembre-se, além de `geom_text()` e `geom_label()`, você tem muitas outras geometrias (*geoms*) no ggplot2 disponíveis para ajudar a anotar seu gráfico.
Algumas ideias:

- Use `geom_hline()` e `geom_vline()` para adicionar linhas de referência.
    Freqüentemente, as tornamos grossas (`linewidth = 2`) e brancas (`color = white`) e as desenhamos abaixo da camada de dados primária.
    Isso os torna fáceis de ver, sem desviar a atenção dos dados.

- Use `geom_rect()` para desenhar um retângulo ao redor dos pontos de interesse.
    Os limites do retângulo são definidos pela estética `xmin`, `xmax`, `ymin`, `ymax`.
    Como alternativa, consulte o [pacote ggforce](https://ggforce.data-imaginist.com/index.html), especificamente [`geom_mark_hull()`](https://ggforce.data-imaginist.com/reference/geom_mark_hull.html), que permite anotar subconjuntos de pontos.

- Use `geom_segment()` com o argumento `arrow` para chamar a atenção para um ponto com uma seta.
    Use a estética `x` e `y` para definir o local inicial e `xend` e `yend` para definir o local final.

Outra função útil para adicionar anotações aos gráficos é `annotate()`.
Como regra geral, *geoms* são geralmente úteis para destacar um subconjunto de dados, enquanto `annotate()` é útil para adicionar um ou poucos elementos de anotação a um gráfico.

Para demonstrar o uso de `annotate()`, vamos criar algum texto para adicionar ao nosso gráfico.
O texto é um pouco longo, então usaremos `stringr::str_wrap()` para adicionar quebras de linha automaticamente, dado o número de caracteres que você deseja por linha:

```{r}
tendencia_texto <- "Motores com maiores cilindradas tendem a ter menor eficiência de combustível." |>
  str_wrap(width = 30)
tendencia_texto
```

Em seguida, adicionamos duas camadas de anotação: uma com um argumento *geom* igual à `label` e outra igual à `segment`.
As estéticas `x` e `y` em ambos definem onde a anotação deve começar, e as estéticas `xend` e `yend` na anotação do segmento definem a localização final do segmento.
Observe também que o segmento é denominado como uma seta.

```{r}
#| fig-alt: |
#|   Gráfico de dispersão de eficiência de combustível nas rodovias versus cilindradas dos carros. Uma seta
#|   vermelha apontando para baixo segue a tendência dos pontos e a anotação 
#|   colocada ao lado da seta diz "Motores com maiores cilindradas tendem a ter menor eficiência de combustível".  
#|   A seta e o texto da anotação é vermelha. 

ggplot(milhas, aes(x = cilindrada, y = rodovia)) +
  geom_point() +
  annotate(
    geom = "label", x = 3.5, y = 38,
    label = tendencia_texto,
    hjust = "left", color = "red"
  ) +
  annotate(
    geom = "segment",
    x = 3, y = 35, xend = 5, yend = 25, color = "red",
    arrow = arrow(type = "closed")
  )
```

A anotação é uma ferramenta poderosa para comunicar as principais conclusões e recursos interessantes de suas visualizações.
O único limite é a sua imaginação (e a sua paciência com o posicionamento das anotações para serem esteticamente agradáveis)!

### Exercícios

1. Use `geom_text()` com posições infinitas para colocar texto nos quatro cantos do gráfico.

2. Use `annotate()` para adicionar uma *geom* de ponto no meio de seu último gráfico sem ter que criar um tibble.
    Personalize a forma, o tamanho ou a cor do ponto.

3. Como os rótulos com `geom_text()` interagem com o facetamento (*faceting*)?
    Como você pode adicionar um rótulo a uma única faceta?
    Como você pode colocar um rótulo diferente em cada faceta?
    (Dica: pense no conjunto de dados que está sendo passado para `geom_text()`.)

4. Quais argumentos para `geom_label()` controlam a aparência do fundo da caixa?

5. Quais são os quatro argumentos para `arrow()`?
    Como eles funcionam?
    Crie uma série de gráficos que demonstrem as opções mais importantes.

## Escalas

A terceira maneira de melhorar a comunicação do seu enredo é ajustar a escala.
As escalas controlam como os mapeamentos estéticos se manifestam visualmente.

### Escalas padrão

Normalmente o ggplot2 adiciona automaticamente as escalas para você.
Por exemplo, quando você digita:

```{r}
#| label: default-scales
#| fig-show: "hide"

ggplot(milhas, aes(x = cilindrada, y = rodovia)) +
  geom_point(aes(color = classe))
```

ggplot2 adiciona automaticamente uma escala por trás dos panos:

```{r}
#| fig-show: "hide"

ggplot(milhas, aes(x = cilindrada, y = rodovia)) +
  geom_point(aes(color = classe)) +
  scale_x_continuous() +
  scale_y_continuous() +
  scale_color_discrete()
```

Observe o esquema de nomenclatura das escalas: `scale_` seguido do nome da estética, depois `_` e depois o nome da escala.
As escalas padrão são nomeadas de acordo com o tipo de variável com a qual se alinham: contínua, discreta, datahora ou data.
`scale_x_continuous()` coloca os valores numéricos de `cilindrada` em uma linha numérica contínua no eixo x, `scale_color_discrete()` escolhe cores para cada uma das `classes` de carro, etc.
Existem também muitas escalas fora do padrão que você aprenderá a seguir.

As escalas padrão foram cuidadosamente escolhidas para fazer um bom trabalho para uma ampla gama de insumos.
No entanto, você pode querer substituir os padrões por dois motivos:

- Você pode querer ajustar alguns parâmetros da escala padrão.
    Isso permite que você faça coisas como alterar as quebras nos eixos ou os rótulos das teclas na legenda.

- Você pode querer substituir completamente a escala e usar um algoritmo completamente diferente.
    Muitas vezes você pode fazer melhor que o padrão porque sabe mais sobre os dados.

### Marcações de eixo e chaves da legenda

Coletivamente, eixos e legendas são chamados de **guias**.
Os eixos são usados ​​para estética x e y; legendas são usadas para todo o resto.

Existem dois argumentos principais que afetam a aparência dos marcadores nos eixos e das chaves na legenda: `breaks` (quebras) e `labels` (rótulos).
As quebras (*breaks*) controlam a posição dos marcadores ou os valores associados às chaves.
Os rótulos (*labels*) controlam o texto associado a cada marcador/chave.
O uso mais comum de `breaks` é substituir a escolha padrão:

```{r}
#| fig-alt: |
#|   Gráfico de dispersão de eficiência de combustível nas rodovias versus cilindradas,
#|   coloridos por tipo de tração. O eixo y tem quebras começando em 15 e terminando em 40, 
#|   aumentando a cada 5.

ggplot(milhas, aes(x = cilindrada, y = rodovia, color = tracao)) +
  geom_point() +
  scale_y_continuous(breaks = seq(15, 40, by = 5)) 
```

Você pode usar `labels` da mesma maneira (um vetor de caracteres do mesmo tamanho que `breaks`), mas também pode configurá-lo como `NULL` para suprimir completamente os rótulos.
Isto pode ser útil para mapas ou para publicar gráficos onde não é possível compartilhar os números absolutos.
Você também pode usar `breaks` e `labels` para controlar a aparência das legendas.
Para escalas discretas para variáveis ​​categóricas, `rótulos` podem ser uma lista nomeada de nomes de níveis existentes e os rótulos desejados para eles.

```{r}
#| fig-alt: |
#|   Gráfico de dispersão de eficiência de combustível nas rodovias versus cilindradas dos carros, colorido
#|   por tipo de tração. Os eixos x e y não possuem rótulos nas marcações dos eixos.
#|   A legenda possui rótulos personalizadas: 4x4, dianteira, traseira.

ggplot(milhas, aes(x = cilindrada, y = rodovia, color = tracao)) +
  geom_point() +
  scale_x_continuous(labels = NULL) +
  scale_y_continuous(labels = NULL) +
  scale_color_discrete(labels = c("4" = "4x4", "d" = "dianteira", "t" = "trazeira"))
```

O argumento `labels` juntamente com funções de rotulagem do pacote scales também é útil para formatar números como moeda, porcentagem, etc.
O gráfico à esquerda mostra a rotulagem padrão com `label_dollar()`, que adiciona um cifrão, bem como uma vírgula separadora de milhar.
O gráfico à direita adiciona mais personalização dividindo os valores em dólares por 1.000 e adicionando um sufixo "K" (para "milhares"), bem como adicionando quebras personalizadas.
Observe que `breaks` está na escala original dos dados.

```{r}
#| layout-ncol: 2
#| fig-width: 4
#| fig-alt: |
#|   Dois gráficos boxplot de preço versus corte de diamantes. Os valores discrepantes 
#|   são transparentes. Em ambos os gráficos, os rótulos do eixo x são formatados como dólares.
#|   Os rótulos do eixo x no gráfico começam em US$ 0 e vão até US$ 15.000, aumentando 
#|   a cada US$ 5.000. Os rótulos do eixo x no gráfico à direita começam em US$ 1K e vão até
#|   US$ 19 mil, aumentando a cada US$ 6 mil.

# Left
ggplot(diamante, aes(x = preco, y = corte)) +
  geom_boxplot(alpha = 0.05) +
  scale_x_continuous(labels = label_dollar())

# Right
ggplot(diamante, aes(x = preco, y = corte)) +
  geom_boxplot(alpha = 0.05) +
  scale_x_continuous(
    labels = label_dollar(scale = 1/1000, suffix = "K"), 
    breaks = seq(1000, 19000, by = 6000)
  )
```

Outra função de rótulo interessante é a `label_percent()`:

```{r}
#| fig-alt: |
#|   Gráficos de barras segmentadas de corte, preenchidos segundo níveis de clareza. No eixo y 
#|   os rótulos começam em 0% e vão até 100%, aumentando em 25%. O rótulo do eixo y
#|   o nome é "Porcentagem".

ggplot(diamante, aes(x = corte, fill = transparencia)) +
  geom_bar(position = "fill") +
  scale_y_continuous(name = "Porcentagem", labels = label_percent())
```

Outro uso de `breaks` é quando você tem relativamente poucos pontos de dados e deseja destacar exatamente onde as observações ocorrem.
Por exemplo, veja este gráfico que mostra quando cada presidente dos EUA iniciou e terminou o seu mandato.

```{r}
#| fig-alt: |
#|   Gráfico de linha do número de identificação de presidentes em relação ao ano em que iniciaram seu mandato
#|   presidencial. O ano de início é marcado com um ponto e um segmento que começa 
#|   lá e termina no final da presidência. Os rótulos do eixo x são
#|   formatados como anos de dois dígitos começando com um apóstrofo, por exemplo, '53.

presidentes_eua |>
  mutate(id = 33 + row_number()) |>
  ggplot(aes(x = inicio, y = id)) +
  geom_point() +
  geom_segment(aes(xend = fim, yend = id)) +
  scale_x_date(name = NULL, breaks = presidentes_eua$inicio, date_labels = "'%y")
```

Observe que para o argumento `breaks` retiramos a variável `inicio` como um vetor com `presidentes_eua$inicio` porque não podemos fazer um mapeamento estético para este argumento.
Observe também que a especificação de quebras e rótulos para escalas de data e datahora é um pouco diferente:

-   `date_labels` leva uma especificação de formato, na mesma forma que `parse_datetime()`.

-   `date_breaks` (não mostrado aqui), recebe uma string como "2 dias" ou "1 mês".

### Layout da legenda

Na maioria das vezes você usará `breaks` e `labels` para ajustar os eixos.
Embora ambos também funcionem para legendas, existem algumas outras técnicas que você provavelmente usará.

Para controlar a posição geral da legenda, você precisa usar uma configuração `theme()`.
Voltaremos aos temas no final do capítulo, mas, resumidamente, eles controlam as partes não relacionadas a dados do gráfico.
A configuração do tema `legend.position` controla onde a legenda é desenhada:

```{r}
#| layout-ncol: 2
#| fig-width: 4
#| fig-alt: |
#|   Quatro gráficos de dispersão de eficiência de combustível em rodovias versus cilindrada dos carros 
#|   onde os pontos são coloridos com base na classe do carro. No sentido horário, a legenda 
#|   é colocada à direita, esquerda, superior e inferior do gráfico.

base <- ggplot(milhas, aes(x = cilindrada, y = rodovia)) +
  geom_point(aes(color = classe))

base + theme(legend.position = "right") # o padrão
base + theme(legend.position = "left")
base + 
  theme(legend.position = "top") +
  guides(color = guide_legend(nrow = 3))
base + 
  theme(legend.position = "bottom") +
  guides(color = guide_legend(nrow = 3))
```

Se o seu gráfico for curto e largo, coloque a legenda na parte superior ou inferior, e se for alto e estreito, coloque a legenda à esquerda ou à direita.
Você também pode usar `legend.position = "none"` para suprimir completamente a exibição da legenda.

Para controlar a exibição de legendas individuais, use `guides()` junto com `guide_legend()` ou `guide_colorbar()`.
O exemplo a seguir mostra duas configurações importantes: controlar o número de linhas que a legenda usa com `nrow` e substituir uma das estéticas para aumentar os pontos.
Isto é particularmente útil se você usou um `alfa` baixo para exibir muitos pontos em um gráfico.

```{r}
#| fig-alt: |
#|   Gráfico de dispersão de eficiência de combustível nas rodovias versus cilindrada dos carros
#|   onde os pontos são coloridos com base na classe do carro. Sobreposto no gráfico está uma 
#|   curva de suavização. A legenda está na parte inferior e as classes estão listadas 
#|   horizontalmente em duas linhas. Os pontos na legenda são maiores que os pontos 
#|   no gráfico.

ggplot(milhas, aes(x = cilindrada, y = rodovia)) +
  geom_point(aes(color = classe)) +
  geom_smooth(se = FALSE) +
  theme(legend.position = "bottom") +
  guides(color = guide_legend(nrow = 2, override.aes = list(size = 4)))
```

Observe que o nome do argumento em `guides()` corresponde ao nome da estética, assim como em `labs()`.

### Substituindo uma escala

Em vez de apenas ajustar um pouco os detalhes, você pode substituir completamente a escala.
Existem dois tipos de escalas que você provavelmente desejará trocar: escalas de posição contínua e escalas de cores.
Felizmente, os mesmos princípios se aplicam a todas as outras estéticas; portanto, depois de dominar a posição e a cor, você poderá escolher rapidamente outras substituições de escala.

É muito útil traçar transformações de sua variável.
Por exemplo, é mais fácil ver a relação precisa entre `quilate` e `preço` se aplicarmos o logaritmo:

```{r}
#| fig-align: default
#| layout-ncol: 2
#| fig-width: 3
#| fig-alt: |
#|   Dois gráficos de preço versus quilate de diamantes. Dados discretizados em classes e a cor dos 
#|   retângulos que representam cada classe com base no número de pontos que
#|   caem naquela classe. No gráfico à direita, valores de preço e quilates
#|   são registrados como *log* e os rótulos dos eixos mostram os valores representados pelo *log*.

# Esquerda
ggplot(diamante, aes(x = quilate, y = preco)) +
  geom_bin2d()

# Direita
ggplot(diamante, aes(x = log10(quilate), y = log10(preco))) +
  geom_bin2d()
```

Contudo, a desvantagem desta transformação é que os eixos agora são rotulados com os valores transformados (*log*), dificultando a interpretação do gráfico.
Em vez de fazer a transformação no mapeamento estético, podemos fazê-lo com a escala.
Isto é visualmente idêntico, exceto que os eixos são rotulados na escala de dados original.

```{r}
#| fig-alt: |
#|   Gráfico de preço versus quilate de diamantes. Dados discretizados em classes e a cor dos 
#|   retângulos que representam cada classe com base no número de pontos que
#|   caem naquela classe. Os rótulos dos eixos estão na escala de dados original.

ggplot(diamante, aes(x = quilate, y = preco)) +
  geom_bin2d() + 
  scale_x_log10() + 
  scale_y_log10()
```

Outra escala frequentemente personalizada é a cor.
A escala categórica padrão seleciona cores uniformemente espaçadas no círculo cromático.
Alternativas úteis são as escalas ColorBrewer que foram ajustadas manualmente para funcionar melhor para pessoas com tipos comuns de daltonismo.
Os dois gráficos abaixo parecem semelhantes, mas há diferença suficiente nos tons de vermelho e verde para que os pontos à direita possam ser distinguidos até mesmo por pessoas com daltonismo vermelho-verde.[^comunicação-1]

[^communication-1]: Você pode usar uma ferramenta como [SimDaltonism](https://michelf.ca/projects/sim-daltonism/) para simular daltonismo e testar essas imagens.

```{r}
#| fig-align: default
#| layout-ncol: 2
#| fig-width: 3
#| fig-alt: |
#|   Dois gráficos de dispersão de eficiência de combustível nas rodovias versus cilindrada onde os pontos são 
#|   coloridos por tipo de tração. O gráfico à esquerda usa  a paleta de cores padrão do
#| ggplot2 e o gráfico à direita usa uma paleta de cores diferente
#| 

ggplot(milhas, aes(x = cilindrada, y = rodovia)) +
  geom_point(aes(color = tracao))

ggplot(milhas, aes(x = cilindrada, y = rodovia)) +
  geom_point(aes(color = tracao)) +
  scale_color_brewer(palette = "Set1")
```

Não se esqueça de técnicas mais simples para melhorar a acessibilidade.
Se houver apenas algumas cores, você poderá adicionar um mapeamento de forma redundante.
Isso também ajudará a garantir que seu gráfico seja interpretável em preto e branco.

```{r}
#| fig-alt: |
#|   Dois gráficos de dispersão de eficiência de combustível nas rodovias versus cilindrada dos carros, onde ambas as cores 
#|   e a forma dos pontos são baseadas no tipo de tração. A paleta de cores não
#|   é a paleta padrão do ggplot2.

ggplot(milhas, aes(x = cilindrada, y = rodovia)) +
  geom_point(aes(color = tracao, shape = tracao)) +
  scale_color_brewer(palette = "Set1")
```

As escalas ColorBrewer estão documentadas online em <https://colorbrewer2.org/> e disponibilizadas no R por meio do pacote **RColorBrewer**, de Erich Neuwirth.
A @fig-brewer mostra a lista completa de todas as paletas.
As paletas sequenciais (superior) e divergente (inferior) são particularmente úteis se seus valores categóricos estiverem ordenados ou tiverem um "meio".
Isso geralmente surge se você usou `cut()` para transformar uma variável contínua em uma variável categórica.

```{r}
#| label: fig-brewer
#| echo: false
#| fig-cap: All colorBrewer scales.
#| fig-asp: 2.5
#| fig-alt: |
#|   Todas as escalas colorBrewer. Um grupo vai de cores claras para escuras. 
#|   Outro grupo é definido como cores não ordinais. E o útlimo grupo tem 
#|   escalas divergentes (de escuro para claro para escuro novamente). Em cada grupo 
#|   existem várias paletas.

par(mar = c(0, 3, 0, 0))
RColorBrewer::display.brewer.all()
```

Quando você tiver um mapeamento predefinido entre valores e cores, use `scale_color_manual()`.
Por exemplo, se mapearmos o partido presidencial nos EUA por cor, queremos usar o mapeamento padrão de vermelho para os republicanos e azul para os democratas.
Uma abordagem para atribuir essas cores é usar códigos de cores hexadecimais:

```{r}
#| fig-alt: |
#|   Gráfico linear do número de identificação de presidentes dos EUA em relação ao ano em que iniciaram seu mandato 
#|   presidêncial. O ano de início é marcado com um ponto e um segmento que começa 
#|   lá e termina no final da presidência. Os presidentes democratas são
#|   representado em azul e os republicanos em vermelho.

presidentes_eua |>
  mutate(id = 33 + row_number()) |>
  ggplot(aes(x = inicio, y = id, color = partido)) +
  geom_point() +
  geom_segment(aes(xend = fim, yend = id)) +
  scale_color_manual(values = c(Republicano = "#E81B23", Democrata = "#00AEF3"))
```

Para cores contínuas, você pode usar as escalas `scale_color_gradient()` ou `scale_fill_gradient()`.
Se você tiver uma escala divergente, poderá usar `scale_color_gradient2()`.
Isso permite atribuir, por exemplo, cores diferentes a valores positivos e negativos.
Às vezes, isso também é útil se você quiser distinguir pontos acima ou abaixo da média.

Outra opção é usar as escalas de cores viridis.
Os designers, Nathaniel Smith e Stéfan van der Walt, adaptaram cuidadosamente esquemas de cores contínuas que são perceptíveis para pessoas com várias formas de daltonismo, bem como perceptivamente uniformes tanto em cores quanto em preto e branco.
Essas escalas estão disponíveis como paletas contínuas (`c`), discretas (`d`) e agrupadas (`b`) no ggplot2.

```{r}
#| fig-align: default
#| layout-ncol: 2
#| fig-width: 3
#| fig-asp: 0.75
#| fig-alt: |
#|   Três gráficos hexagonais onde a cor dos hexágonos mostram o número de observações 
#|   que caem naquela classe hexagonal. O primeiro gráfico usa o padrão contínuo
#|   de escala do ggplot2. O segundo gráfico utiliza o viridis, escala contínua, e o
#|   o terceiro gráfico usa a escala viridis discretizada.

df <- tibble(
  x = rnorm(10000),
  y = rnorm(10000)
)

ggplot(df, aes(x, y)) +
  geom_hex() +
  coord_fixed() +
  labs(title = "Padrão, contínua", x = NULL, y = NULL)

ggplot(df, aes(x, y)) +
  geom_hex() +
  coord_fixed() +
  scale_fill_viridis_c() +
  labs(title = "Viridis, contínua", x = NULL, y = NULL)

ggplot(df, aes(x, y)) +
  geom_hex() +
  coord_fixed() +
  scale_fill_viridis_b() +
  labs(title = "Viridis, agrupada", x = NULL, y = NULL)
```

Observe que todas as escalas de cores vêm em duas variedades: `scale_color_*()` e `scale_fill_*()` para a estética `color` e `fill` respectivamente (as escalas de cores estão disponíveis nas grafias do Reino Unido e dos EUA).

### Zoom

Existem três maneiras de controlar os limites do gráfico:

1. Ajustando quais dados são plotados.
2. Definir os limites em cada escala.
3. Configurando `xlim` e `ylim` em `coord_cartesian()`.

Demonstraremos essas opções em uma série de gráficos.
O gráfico à esquerda mostra a relação entre o tamanho do motor e a eficiência de combustível, colorida por tipo de trem de força.
O gráfico à direita mostra as mesmas variáveis, mas subdivide os dados que são plotados.
A divisão dos dados em subconjuntos afetou as escalas x e y, bem como a curva suave.

```{r}
#| layout-ncol: 2
#| fig-width: 4
#| message: false
#| fig-alt: |
#|   À esquerda, gráfico de dispersão da eficiência de combustível nas rodovias versus cilindrada. 
#|   A curva suave sobreposta mostra uma diminuição e, em seguida, 
#|   tendência crescente, como um taco de hóquei. À direita, as mesmas variáveis 
#|   são mostradas com cilindrada variando apenas de 5 a 6 e eficiência na rodovia 
#|   variando apenas de 10 a 25. A curva suave sobreposta mostra uma
#|   tendência que está aumentando ligeiramente primeiro e depois diminuindo. 

# Esquerda
ggplot(milhas, aes(x = cilindrada, y = rodovia)) +
  geom_point(aes(color = tracao)) +
  geom_smooth()

# Direita
milhas |>
  filter(cilindrada >= 5 & cilindrada <= 6 & rodovia >= 10 & rodovia <= 25) |>
  ggplot(aes(x = cilindrada, y = rodovia)) +
  geom_point(aes(color = tracao)) +
  geom_smooth()
```

Vamos compará-los com os dois gráficos abaixo, onde o gráfico à esquerda define os `limites` em escalas individuais e o gráfico à direita os define em `coord_cartesian()`.
Podemos ver que reduzir os limites equivale a subdividir os dados.
Portanto, para ampliar uma região do gráfico, geralmente é melhor usar `coord_cartesian()`.

```{r}
#| layout-ncol: 2
#| fig-width: 4
#| message: false
#| warning: false
#| fig-alt: |
#|   À esquerda, gráfico de dispersão de eficiência de combustível nas rodovias versus cilindrada, com
#|   a cilindrada de 5 a 6 e o eficiência em rodovias variando de
#|   10 a 25. A curva suave sobreposta mostra uma tendência ligeiramente 
#|   aumentando primeiro e depois diminuindo. À direita, as mesmas variáveis 
#|   são mostradas com os mesmos limites, porém a curva suave sobreposta
#|   mostra uma tendência relativamente plana com um ligeiro aumento no final.

# Esquerda
ggplot(milhas, aes(x = cilindrada, y = rodovia)) +
  geom_point(aes(color = tracao)) +
  geom_smooth() +
  scale_x_continuous(limits = c(5, 6)) +
  scale_y_continuous(limits = c(10, 25))

# Direita
ggplot(milhas, aes(x = cilindrada, y = rodovia)) +
  geom_point(aes(color = tracao)) +
  geom_smooth() +
  coord_cartesian(xlim = c(5, 6), ylim = c(10, 25))
```

Por outro lado, definir os “limites” em escalas individuais é geralmente mais útil se você quiser *expandir* os limites, por exemplo, para combinar escalas em gráficos diferentes.
Por exemplo, se extrairmos duas classes de carros e plotá-las separadamente, será difícil comparar os gráficos porque todas as três escalas (o eixo x, o eixo y e a estética da cor) têm intervalos diferentes.

```{r}
#| layout-ncol: 2
#| fig-width: 4
#| fig-alt: |
#|   À esquerda, um gráfico de dispersão de eficiência de combustível nas rodovias versus cilindradas de SUVs.
#|   À direita, um gráfico de dispersão das mesmas variáveis ​​para carros compactos..
#|   Os pontos são coloridos por tipo de tração os gráficos. Entre os SUVs mais 
#|  carros têm tração 4x4 e os demais têm tração traseira, enquanto 
#|   entre os carros compactos, mais carros têm tração dianteira e os outros 
#|   têm tração 4x4. O gráfico do SUV mostra uma clara relação negativa
#|   entre eficiência e cilindrada nas rodovias enquanto que no gráfico de carros compactos 
#|   o relacionamento é muito mais achatado.

suv <- milhas |> filter(classe == "suv")
compacto <- milhas |> filter(classe == "compacto")

# Esquerda
ggplot(suv, aes(x = cilindrada, y = rodovia, color = tracao)) +
  geom_point()

# Direita
ggplot(compacto, aes(x = cilindrada, y = rodovia, color = tracao)) +
  geom_point()
```

Uma forma de superar este problema é compartilhar escalas em múltiplos gráficos, treinando as escalas com os “limites” dos dados completos.

```{r}
#| layout-ncol: 2
#| fig-width: 4
#| fig-alt: |
#|   À esquerda, um gráfico de dispersão da eficiência de combustível nas rodovias versus cilindrada de SUVs.
#|   À direita, um gráfico de dispersão das mesmas variáveis ​​para carros compactos.
#|   Os pontos são coloridos por tipo de tração. Ambos os gráficos são plotados 
#|   na mesma escala para eficiência de combustível em rodovias, cilindrada e tipo de tração,
#|   resultando na legenda mostrando todos os três tipos (dianteiro, traseiro e nas 4 rodas)
#|   para ambos os gráficos, embora não haja SUVs com tração dianteira e
#|   não haja carros compactos com tração traseira. Como as escalas x e y são iguais, 
#|   e vão muito além do mínimo e máximo da eficiência na rodovia e cilindradas, 
#|   os pontos não ocupam toda a área do gráfico.

escala_x <- scale_x_continuous(limits = range(milhas$cilindrada))
escala_y <- scale_y_continuous(limits = range(milhas$rodovia))
escala_cor <- scale_color_discrete(limits = unique(milhas$tracao))

# Esquerda
ggplot(suv, aes(x = cilindrada, y = rodovia, color = tracao)) +
  geom_point() +
  escala_x +
  escala_y +
  escala_cor

# Direita
ggplot(compacto, aes(x = cilindrada, y = rodovia, color = tracao)) +
  geom_point() +
  escala_x +
  escala_y +
  escala_cor
```

Neste caso específico, você poderia simplesmente ter usado o facetamento, mas esta técnica é útil de forma mais geral, se, por exemplo, você quiser espalhar gráficos por várias páginas de um relatório.

### Exercícios

1.  Por que o código a seguir não substitui a escala padrão?

    ```{r}
    #| fig-show: "hide"

    df <- tibble(
      x = rnorm(10000),
      y = rnorm(10000)
    )

    ggplot(df, aes(x, y)) +
      geom_hex() +
      scale_color_gradient(low = "white", high = "red") +
      coord_fixed()
    ```

2.  Qual é o primeiro argumento para cada escala?
    Como ele se compara a `labs()`?

3.  Altere a exibição dos mandatos presidenciais do EUA:

    a.  Combinando as duas variantes que personalizam cores e quebras do eixo x.
    b.  Melhorando a exibição do eixo y.
    c.  Rotulando cada mandato com o nome do presidente.
    d.  Adicionando rótulos informativos ao gráfico.
    e.  Acrescentando quebras a cada 4 anos (isto é mais complicado do que parece!).

4.  Primeiro, crie o seguinte gráfico.
    Em seguida, modifique o código usando `override.aes` para facilitar a visualização da legenda.

    ```{r}
    #| fig-show: hide

    ggplot(diamante, aes(x = quilate, y = preco)) +
      geom_point(aes(color = corte), alpha = 1/20)
    ```

## Temas {#sec-themes}

Finalmente, você pode personalizar os elementos que não são dados de seu gráfico com um tema:

```{r}
#| message: false
#| fig-alt: |
#|   Gráfico de dispersão do eficiência de combutível nas rodovias versus cilindrada dos carros, colorido por classe 
#|   dos carros. O fundo do gráfico é branco, com linhas de grade cinza.

ggplot(milhas, aes(x = cilindrada, y = rodovia)) +
  geom_point(aes(color = classe)) +
  geom_smooth(se = FALSE) +
  theme_bw()
```

O ggplot2 inclui os oito temas mostrados na @fig-themes, com `theme_gray()` como padrão.[^communication-2]
Muitos outros estão incluídos em pacotes complementares como **ggthemes** (<https://jrnold.github.io/ggthemes>), de Jeffrey Arnold.
Você também pode criar seus próprios temas, se estiver tentando combinar com um estilo corporativo ou de periódico específico.

[^communication-2]: Muitas pessoas se perguntam por que o tema padrão tem um fundo cinza.
    Esta foi uma escolha deliberada porque apresenta os dados e ao mesmo tempo torna as linhas da grade visíveis.
    As linhas de grade brancas são visíveis (o que é importante porque auxiliam significativamente no julgamento de posição), mas têm pouco impacto visual e podemos facilmente desligá-las.
    O fundo cinza confere ao gráfico uma cor tipográfica semelhante ao texto, garantindo que os gráficos se ajustem ao fluxo de um documento sem sobressair com um fundo branco brilhante.
    Finalmente, o fundo cinza cria um campo contínuo de cor que garante que o enredo seja percebido como uma entidade visual única.

```{r}
#| label: fig-themes
#| echo: false
#| fig-cap: Os oito temas incluídos no ggplot2.
#| fig-alt: |
#|   Oito gráficos de barras criados com ggplot2, cada um 
#|   com um dos oito temas integrados: 
#|   theme_bw() - Fundo branco com linhas de grade,
#|   theme_light() - Eixos claros e linhas de grade,
#|   theme_classic() - Tema clássico, eixos mas sem grade,
#|   lines, theme_linedraw() - Somente linhas pretas, 
#|   theme_dark() - Fundo escuro para contraste,
#|   theme_minimal() - Tema mínimo, sem fundo,
#|   theme_gray() - Fundo cinza (tema padrão),
#|   theme_void() - Tema vazio, apenas geoms são visíveis.

knitr::include_graphics("images/visualization-themes.png")
```

Também é possível controlar componentes individuais de cada tema, como o tamanho e a cor da fonte usada no eixo y.
Já vimos que `legend.position` controla onde a legenda é desenhada.
Existem muitos outros aspectos da legenda que podem ser personalizados com `theme()`.
Por exemplo, no gráfico abaixo mudamos a direção da legenda e também colocamos uma borda preta ao redor dela.
Observe que a personalização da caixa de legenda e dos elementos do título do gráfico do tema é feita com as funções `element_*()`.
Essas funções especificam o estilo de componentes que não são dos dados, por exemplo, o texto do título está em negrito no argumento `face` de `element_text()` e a cor da borda da legenda é definida no argumento `color` de `element_rect()`.
Os elementos do tema que controlam a posição do título e da legenda são `plot.title.position` e `plot.caption.position`, respectivamente.
No gráfico a seguir, eles são definidos como `"plot"` para indicar que esses elementos estão alinhados a toda a área do gráfico, em vez do painel de plotagem (o padrão).
Alguns outros componentes `theme()` úteis são usados ​​para alterar o posicionamento do formato do título e do texto da legenda.

```{r}
#| fig-alt: |
#|   Um gráfico de dispersão de eficiência de combustível nas rodovias versus cilindrada, colorido 
#|   por tração. O gráfico é entitulado 'Maior número de cilindradas tendem a ter menor economia de combustível' 
#|   com a legenda informando a fonte dos dados, fueleconomy.gov.
#|   A legenda e título estão justificadas à esquerda, a legenda está dentro do gráfico
#|   com boarda preta.

ggplot(milhas, aes(x = cilindrada, y = rodovia, color = tracao)) +
  geom_point() +
  labs(
    title = "Maior número de cilindradas tendem a ter menor economia de combustível",
    caption = "Source: https://fueleconomy.gov."
  ) +
  theme(
    legend.position = c(0.6, 0.7),
    legend.direction = "horizontal",
    legend.box.background = element_rect(color = "black"),
    plot.title = element_text(face = "bold"),
    plot.title.position = "plot",
    plot.caption.position = "plot",
    plot.caption = element_text(hjust = 0)
  )
```

Para uma visão geral de todos os componentes `theme()`, consulte a ajuda com `?theme`.
O [livro ggplot2](https://ggplot2-book.org/) também é um ótimo lugar para obter todos os detalhes sobre temas.

### Exercícios

1.  Escolha um tema oferecido pelo pacote ggthemes e aplique-o no último gráfico que você fez.
2.  Deixe os rótulos dos eixos do seu gráfico em azul e em negrito.

## Layout

Até agora falamos sobre como criar e modificar um único gráfico.
E se você tiver vários gráficos que deseja organizar de uma determinada maneira?
O pacote patchwork permite combinar gráficos separados no mesmo gráfico.
Carregamos este pacote no início do capítulo.

Para colocar dois gráficos próximos um do outro, você pode simplesmente adicioná-los um ao outro.
Observe que primeiro você precisa criar os gráficos e salvá-los como objetos (no exemplo a seguir eles são chamados de `p1` e `p2`).
Em seguida, você os coloca um ao lado do outro com `+`.

```{r}
#| fig-width: 6
#| fig-asp: 0.5
#| fig-alt: |
#|   Dois gráficos (um gráfico de dispersão de eficiência de combustível nas rodovias versus cilindrada e um 
#|   boxplots de eficiência nas rodovias versus tração) colocados lado 
#|   a lado.

p1 <- ggplot(milhas, aes(x = cilindrada, y = rodovia)) + 
  geom_point() + 
  labs(title = "Gráfico 1")
p2 <- ggplot(milhas, aes(x = tracao, y = rodovia)) + 
  geom_boxplot() + 
  labs(title = "Gráfico 2")
p1 + p2
```

É importante notar que no trecho de código acima não usamos uma nova função do pacote patchwork.
Em vez disso, o pacote adicionou uma nova funcionalidade ao operador `+`.

Você também pode criar layouts de gráficos complexos com patchwork.
A seguir, `|` coloca `p1` e `p3` próximos um do outro e `/` move `p2` para a próxima linha.

```{r}
#| fig-width: 6
#| fig-asp: 0.8
#| fig-alt: |
#|   Três gráficos dispostos de forma que o primeiro e a terceiro fiquem próximos um do outro
#|   e o segundo gráfico fique abaixo deles. O primeiro gráfico é um
#|   gráfico de dispersão de eficiência em rodovias versus cilindrada, o terceiro gráfico é um
#|   gráfico de dispersão da eficiência em rodovias versus eficiência na cidade, e o terceiro gráfico é
#|   boxplots de eficiência em rodovias versus tração) colocado abaixo 
#|   dos demais
p3 <- ggplot(milhas, aes(x = cidade, y = rodovia)) + 
  geom_point() + 
  labs(title = "Gráfico 3")
(p1 | p3) / p2
```

Além disso, patchwork permite coletar legendas de vários gráficos em uma legenda comum, personalizar o posicionamento da legenda, bem como as dimensões dos gráficos e adicionar um título, subtítulo, legenda comum, etc.
Abaixo criamos 5 gráficos.
Desativamos as legendas nos gráficos boxplot e no gráfico de dispersão e coletamos as legendas para os gráficos de densidade na parte superior do gráfico com `& theme(legend.position = "top")`.
Observe o uso do operador `&` aqui em vez do usual `+`.
Isso ocorre porque estamos modificando o tema do gráfico do *patchwork* em oposição aos ggplots individuais.
A legenda é colocada no topo, dentro de `guide_area()`.
Por fim, também personalizamos as alturas dos vários componentes do nosso patchwork - o guia tem altura 1, os gráficos de caixa 3, os gráficos de densidade 2 e o gráfico de dispersão facetado tem 4.
Patchwork divide a área que você reservou para seu gráfico usando esta escala e posiciona os componentes de acordo.

```{r}
#| fig-width: 8
#| fig-asp: 1
#| fig-alt: |
#|   Cinco gráficos dispostos de forma que os dois primeiros fiquem próximos uns dos outros.
#|   Os gráficos três e quatro estão abaixo deles. E o quinto gráfico se estende abaixo deles. 
#|   O gráfico patchwork é entitulado "Eficiência nas cidades e rodovias com diferentes 
#|   trações" e com legenda "Fonte: https://fueleconomy.gov". 
#|   Os dois primeiros gráficos são gráficos boxplot. Os gráficos 3 e 4 são de densidade.
#|   O quinto gráfico é um gráfico de dispersão facetado. Cada um desses gráficos mostra
#|   geoms coloridos pelo tração, mas o gráfico patchwork tem apenas uma legenda que se
#|   aplica a todos eles, acima dos gráficos e abaixo do título.

p1 <- ggplot(milhas, aes(x = tracao, y = cidade, color = tracao)) + 
  geom_boxplot(show.legend = FALSE) + 
  labs(title = "Gráfico 1")

p2 <- ggplot(milhas,aes(x = tracao, y = cidade, color = tracao)) + 
  geom_boxplot(show.legend = FALSE) + 
  labs(title = "Gráfico 2")

p3 <- ggplot(milhas, aes(x = cidade, color = tracao, fill = tracao)) + 
  geom_density(Gráfico = 0.5) + 
  labs(title = "Gráfico 3")

p4 <- ggplot(milhas, aes(x = rodovia, color = tracao, fill = tracao)) + 
  geom_density(alpha = 0.5) + 
  labs(title = "Gráfico 4")

p5 <- ggplot(milhas, aes(x = cidade, y = rodovia, color = tracao)) + 
  geom_point(show.legend = FALSE) + 
  facet_wrap(~tracao) +
  labs(title = "Gráfico 5")

(guide_area() / (p1 + p2) / (p3 + p4) / p5) +
  plot_annotation(
    title = "Eficiência nas cidades e rodovias com diferentes trações",
    caption = "Fonte: https://fueleconomy.gov."
  ) +
  plot_layout(
    guides = "collect",
    heights = c(1, 3, 2, 4)
    ) &
  theme(legend.position = "top")
```

Se você quiser saber mais sobre como combinar e fazer o layout de vários gráficos com o pacote patchwork, recomendamos consultar os guias no site do pacote: <https://patchwork.data-imaginist.com>.

### Exercícios

1.  O que acontece se você omitir os parênteses no layout de gráfico a seguir.
    Você pode explicar por que isso acontece?

    ```{r}
    #| fig-show: hide

    p1 <- ggplot(milhas, aes(x = cilindrada, y = rodovia)) + 
      geom_point() + 
      labs(title = "Gráfico 1")
    p2 <- ggplot(milhas, aes(x = tracao, y = rodovia)) + 
      geom_boxplot() + 
      labs(title = "Gráfico 2")
    p3 <- ggplot(milhas, aes(x = cidade, y = rodovia)) + 
      geom_point() + 
      labs(title = "Gráfico 3")

    (p1 | p2) / p3
    ```

2.  Usando os três gráficos do exercício anterior, recrie a seguinte gráfico *patchwork*.

    ```{r}
    #| fig-width: 7
    #| fig-asp: 0.8
    #| echo: false
    #| fig-alt: |
    #|   Três gráficos: O gráfico 1 é um gráfico de dispersão de eficiência nas rodovias versus cilindrada. 
    #|   O gráfico 2 é um gráfico boxplot de eficiência em rodovias versus tração. 
    #|   O gráfico 3 consiste em gráficos boxplot de eficiência na cidade versus tração. 
    #|   O gráfico 1 está na primeira linha. Os gráficos 2 e 3 estão na  linha seguinte, cada um vai até 
    #|   metade da largura do gráfico 1. O gráfico 1 é rotulado como "Fig. A", o gráfico 2 é rotulado 
    #|   "Fig. B", e o gráfico 3 é rotulado "Fig. C".

    p1 / (p2 + p3) +
      plot_annotation(
        tag_levels = c("A"), 
        tag_prefix = "Fig. ",
        tag_suffix = ":"
      )
    ```

## Resumo

Neste capítulo você aprendeu como adicionar rótulos aos gráficos, como título, subtítulo, legenda, bem como modificar rótulos de eixo padrão, usar anotações para adicionar texto informativo ao seu gráfico ou para destacar pontos de dados específicos, personalizar as escalas dos eixos e alterar o tema do seu enredo.
Você também aprendeu como combinar vários gráficos em um único gráfico usando tanto layouts simples e complexos de gráficos.

Embora você tenha aprendido até agora como criar muitos tipos diferentes de gráficos e como personalizá-los usando uma variedade de técnicas, mal arranhamos a superfície do que você pode criar com o ggplot2.
Se você deseja obter uma compreensão abrangente do ggplot2, recomendamos a leitura do livro [*ggplot2: Elegant Graphics for Data Analysis*](https://ggplot2-book.org).
Outros recursos úteis são o [*R Graphics Cookbook*](https://r-graphics.org) de Winston Chang e [*Fundamentals of Data Visualization*](https://clauswilke.com/dataviz/) de Claus Wilke .
