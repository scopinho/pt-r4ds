# Fun√ß√µes {#sec-functions}

```{r}
#| echo: false
#| results: asis

source("_common.R")

```

## Introdu√ß√£o

Uma das melhores maneiras de melhorar sua atua√ß√£o como cientista de dados √© escrever fun√ß√µes.
As fun√ß√µes permitem automatizar tarefas comuns de uma forma mais poderosa e geral do que copiar e colar o c√≥digo.
Escrever uma fun√ß√£o tem quatro grandes vantagens em rela√ß√£o ao copiar e colar:

1.  Voc√™ pode dar a uma fun√ß√£o um nome evocativo que torne seu c√≥digo mais f√°cil de entender.

2.  √Ä medida que os requisitos mudam, voc√™ s√≥ precisa atualizar o c√≥digo em um local, em vez de v√°rios.

3.  Voc√™ elimina a chance de cometer erros acidentais ao copiar e colar (ou seja, atualizar o nome de uma vari√°vel em um lugar, mas n√£o em outro).

4.  Torna mais f√°cil reutilizar o trabalho de um projeto em outro, aumentando sua produtividade ao longo do tempo.

Uma boa regra geral √© considerar escrever uma fun√ß√£o sempre que voc√™ copiar e colar um bloco de c√≥digo mais de duas vezes (ou seja, quando voc√™ tiver tr√™s c√≥pias do mesmo c√≥digo).
Neste cap√≠tulo, voc√™ aprender√° sobre tr√™s tipos √∫teis de fun√ß√µes:

-   Fun√ß√µes vetoriais que recebem um ou mais vetores como entrada e retornam um vetor como sa√≠da.
-   Fun√ß√µes de *data frames* que recebem um *data frame* como entrada e retornam um *data frame* como sa√≠da.
-   Fun√ß√µes de plotagem que recebem um *data frame* como entrada e retornam um gr√°fico como sa√≠da.

Cada uma dessas se√ß√µes inclui muitos exemplos para ajud√°-lo a generalizar esses padr√µes que voc√™ v√™.
Esses exemplos n√£o seriam poss√≠veis sem a ajuda do pessoal do Twitter, e encorajamos voc√™ seguir os links nos coment√°rios para ver as inspira√ß√µes originais.
Voc√™ tamb√©m pode querer ler os tweets motivacionais originais para [fun√ß√µes gerais](https://twitter.com/hadleywickham/status/1571603361350164486) e [fun√ß√µes de plotagem](https://twitter.com/hadleywickham/status/1574373127349575680) para ver ainda mais fun√ß√µes.

### Pr√©-requisitos

Resumiremos uma variedade de fun√ß√µes do pacote tidyverse.
Tamb√©m usaremos o pacote dados como fonte de dados familiares para usar em nossas fun√ß√µes.

```{r}
#| message: false
library(tidyverse)
library(dados)
```

## Fun√ß√µes vetoriais

Come√ßaremos com fun√ß√µes vetoriais: fun√ß√µes que recebem um ou mais vetores e retornam um resultado vetorial.
Por exemplo, d√™ uma olhada neste c√≥digo.
O que isso faz?

```{r}
df <- tibble(
  a = rnorm(5),
  b = rnorm(5),
  c = rnorm(5),
  d = rnorm(5),
)

df |> mutate(
  a = (a - min(a, na.rm = TRUE)) / 
    (max(a, na.rm = TRUE) - min(a, na.rm = TRUE)),
  b = (b - min(b, na.rm = TRUE)) / 
    (max(b, na.rm = TRUE) - min(a, na.rm = TRUE)),
  c = (c - min(c, na.rm = TRUE)) / 
    (max(c, na.rm = TRUE) - min(c, na.rm = TRUE)),
  d = (d - min(d, na.rm = TRUE)) / 
    (max(d, na.rm = TRUE) - min(d, na.rm = TRUE)),
)
```

Voc√™ pode advinhar que isso redimensiona cada coluna para ter um intervalo de 0 a 1.
Mas voc√™ percebeu o erro?
Quando Hadley escreveu este c√≥digo, ele cometeu um erro ao copiar e colar e esqueceu de alterar um `a` para um `b`.
Prevenir esse tipo de erro √© um bom motivo para aprender a escrever fun√ß√µes.

### Escrevendo fun√ß√µes

Para escrever uma fun√ß√£o voc√™ precisa primeiro analisar seu c√≥digo repetido para descobrir quais partes s√£o constantes e quais partes variam.
Se pegarmos o c√≥digo acima e extra√≠-lo da fun√ß√£o `mutate()`, ser√° um pouco mais f√°cil ver o padr√£o porque cada repeti√ß√£o agora √© uma linha:

```{r}
#| eval: false

(a - min(a, na.rm = TRUE)) / (max(a, na.rm = TRUE) - min(a, na.rm = TRUE))
(b - min(b, na.rm = TRUE)) / (max(b, na.rm = TRUE) - min(b, na.rm = TRUE))
(c - min(c, na.rm = TRUE)) / (max(c, na.rm = TRUE) - min(c, na.rm = TRUE))
(d - min(d, na.rm = TRUE)) / (max(d, na.rm = TRUE) - min(d, na.rm = TRUE))  
```

Para deixar isso um pouco mais claro, podemos substituir a parte que varia com `‚ñà`:

```{r}
#| eval: false
(‚ñà - min(‚ñà, na.rm = TRUE)) / (max(‚ñà, na.rm = TRUE) - min(‚ñà, na.rm = TRUE))
```

Para transformar isso em uma fun√ß√£o voc√™ precisa de tr√™s coisas:

1.  Um **nome**.
    Aqui usaremos `rescala01` porque esta fun√ß√£o redimensiona um vetor para ficar entre 0 e 1.

2.  Os **argumentos**.
    Os argumentos variam entre as chamadas e nossa an√°lise acima nos diz que temos apenas um.
    Chamaremos de `x` porque este √© o nome convencional para um vetor num√©rico.

3.  O **corpo**.
    O corpo √© o c√≥digo repetido em todas as chamadas.

Ent√£o, voc√™ cria uma fun√ß√£o seguindo o modelo:

```{r}
nome <- function(argumentos) {
  corpo
}
```

Para este caso nos leva a:

```{r}
rescala01 <- function(x) {
  (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
}
```

Neste ponto voc√™ pode testar com algumas entradas simples para ter certeza de que capturou a l√≥gica corretamente:

```{r}
rescala01(c(-10, 0, 10))
rescala01(c(1, 2, 3, NA, 5))
```

Ent√£o voc√™ pode reescrever a chamada para `mutate()` como:

```{r}
df |> mutate(
  a = rescala01(a),
  b = rescala01(b),
  c = rescala01(c),
  d = rescala01(d),
)
```

(No @sec-iteration, voc√™ aprender√° como usar `across()` para reduzir ainda mais a duplica√ß√£o, ent√£o tudo que voc√™ precisar√° √© `df |> mutate(across(a:d, rescala01))`).

### Melhorando nossa fun√ß√£o

Voc√™ pode notar que a fun√ß√£o `rescala01()` faz algum trabalho desnecess√°rio --- em vez de calcular `min()` duas vezes e `max()` uma vez, poder√≠amos calcular o m√≠nimo e o m√°ximo em uma √∫nica etapa com `range( )`:

```{r}
rescala01 <- function(x) {
  intervalo <- range(x, na.rm = TRUE)
  (x - intervalo[1]) / (intervalo[2] - intervalo[1])
}
```

Ou voc√™ pode tentar esta fun√ß√£o em um vetor que inclui um valor infinito:

```{r}
x <- c(1:10, Inf)
rescala01(x)
```

Esse resultado n√£o √© particularmente √∫til, ent√£o poder√≠amos pedir a fun√ß√£o `range()` para ignorar valores infinitos:

```{r}
rescala01 <- function(x) {
  intervalo <- range(x, na.rm = TRUE, finite = TRUE)
  (x - intervalo[1]) / (intervalo[2] - intervalo[1])
}

rescala01(x)
```

Essas mudan√ßas ilustram um benef√≠cio importante das fun√ß√µes: como movemos o c√≥digo repetido para uma fun√ß√£o, s√≥ precisamos fazer a mudan√ßa em um s√≥ lugar.

### Fun√ß√µes de *mutate*

Agora que voc√™ tem a ideia b√°sica de fun√ß√µes, vamos dar uma olhada em v√°rios exemplos.
Come√ßaremos examinando as fun√ß√µes de "*mutate*", ou seja, fun√ß√µes que funcionam bem dentro de `mutate()` e `filter()` porque retornam uma sa√≠da do mesmo comprimento que a entrada.

Vamos come√ßar com uma varia√ß√£o simples de `rescala01()`.
Talvez voc√™ queira calcular o *z-score*, redimensionando um vetor para ter uma m√©dia de zero e um desvio padr√£o de um:

```{r}
z_score <- function(x) {
  (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)
}
```

Ou talvez voc√™ queira encerrar um `case_when()` simples e dar a ele um nome √∫til.
Por exemplo, esta fun√ß√£o `ajusta_mm()` garante que todos os valores de um vetor estejam entre um m√≠nimo ou um m√°ximo:

```{r}
ajusta_mm <- function(x, min, max) {
  case_when(
    x < min ~ min,
    x > max ~ max,
    .default = x
  )
}

ajusta_mm(1:10, min = 3, max = 7)
```

√â claro que as fun√ß√µes n√£o precisam trabalhar apenas com vari√°veis ‚Äã‚Äãnum√©ricas.
Voc√™ pode querer fazer alguma manipula√ß√£o repetida de strings.
Talvez voc√™ precise deixar o primeiro caractere mai√∫sculo:

```{r}
prim_maiusculo <- function(x) {
  str_sub(x, 1, 1) <- str_to_upper(str_sub(x, 1, 1))
  x
}

prim_maiusculo("hello")
```

Ou talvez voc√™ queira retirar sinais de porcentagem, v√≠rgulas e cifr√µes de uma string antes de convert√™-la em um n√∫mero:

```{r}
# https://twitter.com/NVlabormarket/status/1571939851922198530
limpa_numero <- function(x) {
  tem_pct <- str_detect(x, "%")
  num <- x |> 
    str_remove_all("%") |> 
    str_remove_all(",") |> 
    str_remove_all(fixed("$")) |> 
    as.numeric()
  if_else(tem_pct, num / 100, num)
}

limpa_numero("$12,300")
limpa_numero("45%")
```

√Äs vezes, suas fun√ß√µes ser√£o altamente especializadas para uma etapa de an√°lise de dados.
Por exemplo, se voc√™ tiver um monte de vari√°veis ‚Äã‚Äãque registram valores ausentes como 997, 998 ou 999, voc√™ pode querer escrever uma fun√ß√£o para substitu√≠-los por `NA`:

```{r}
ajusta_na <- function(x) {
  if_else(x %in% c(997, 998, 999), NA, x)
}
```

N√≥s nos concentramos em exemplos que usam um √∫nico vetor porque achamos que s√£o os mais comuns.
Mas n√£o h√° raz√£o para que sua fun√ß√£o n√£o possa receber m√∫ltiplas vetores na entrada.

### Fun√ß√µes de resumo

Outra fam√≠lia importante de fun√ß√µes vetoriais s√£o as fun√ß√µes de sumariza√ß√£o, fun√ß√µes que retornam um √∫nico valor para uso em `summarize()`.
√Äs vezes, isso pode ser apenas uma quest√£o de definir um ou dois argumentos padr√£o:

```{r}
virgulas <- function(x) {
  str_flatten(x, collapse = ", ", last = " e ")
}

virgulas(c("gato", "cachorro", "pomba"))
```

Ou voc√™ pode fazer um c√°lculo simples, como o do coeficiente de varia√ß√£o, que divide o desvio padr√£o pela m√©dia:

```{r}
cv <- function(x, na.rm = FALSE) {
  sd(x, na.rm = na.rm) / mean(x, na.rm = na.rm)
}

cv(runif(100, min = 0, max = 50))
cv(runif(100, min = 0, max = 500))
```

Ou talvez voc√™ apenas queira tornar um padr√£o comum mais f√°cil de lembrar, dando-lhe um nome mais significativo:

```{r}
# https://twitter.com/gbganalyst/status/1571619641390252033
num_valores_faltantes <- function(x) {
  sum(is.na(x))
} 
```

Voc√™ tamb√©m pode escrever fun√ß√µes com m√∫ltiplos vetores na entrada.
Por exemplo, talvez voc√™ queira calcular o erro percentual absoluto m√©dio para ajud√°-lo a comparar as previs√µes do modelo com os valores reais:

```{r}
# https://twitter.com/neilgcurrie/status/1571607727255834625
epam <- function(atual, previsto) {
  sum(abs((atual - previsto) / atual)) / length(atual)
}
```

::: callout-note
## RStudio

Depois de come√ßar a escrever fun√ß√µes, existem dois atalhos do RStudio que s√£o muito √∫teis:

-   Para encontrar a defini√ß√£o de uma fun√ß√£o que voc√™ escreveu, coloque o cursor sobre o nome da fun√ß√£o e pressione `F2`.

-   Para pular rapidamente para uma fun√ß√£o, pressione `Ctrl + .` para abrir o arquivo difuso e o localizador de fun√ß√£o e digite as primeiras letras do nome da fun√ß√£o.
    Voc√™ tamb√©m pode navegar para arquivos, se√ß√µes do Quarto e muito mais, tornando-o uma ferramenta de navega√ß√£o muito √∫til.
:::

### Exerc√≠cios

1.  Pratique transformar os seguintes trechos de c√≥digo em fun√ß√µes.
    Pense no que cada fun√ß√£o faz.
    Como voc√™ chamaria cada fun√ß√£o?
    Quantos argumentos s√£o necess√°rios?

    ```{r}
    #| eval: false

    mean(is.na(x))
    mean(is.na(y))
    mean(is.na(z))

    x / sum(x, na.rm = TRUE)
    y / sum(y, na.rm = TRUE)
    z / sum(z, na.rm = TRUE)

    round(x / sum(x, na.rm = TRUE) * 100, 1)
    round(y / sum(y, na.rm = TRUE) * 100, 1)
    round(z / sum(z, na.rm = TRUE) * 100, 1)
    ```

2.  Na segunda variante de `rescala01()`, valores infinitos permanecem inalterados.
    Voc√™ pode reescrever `rescale01()` para que `-Inf` seja mapeado para 0 e `Inf` seja mapeado para 1?

3.  Dado um vetor de datas de nascimento, escreva uma fun√ß√£o para calcular a idade em anos.

4.  Escreva suas pr√≥prias fun√ß√µes para calcular a vari√¢ncia e a assimetria de um vetor num√©rico.
    Voc√™ pode procurar as defini√ß√µes na Wikipedia ou em outro lugar.

5.  Escreva `ambos_na()`, uma fun√ß√£o de resumo que pega dois vetores do mesmo comprimento e retorna o n√∫mero de posi√ß√µes que possuem um `NA` em ambos os vetores.

6.  Leia a documenta√ß√£o para descobrir o que as fun√ß√µes a seguir fazem.
    Por que elas s√£o √∫teis mesmo sendo t√£o pequenas?

    ```{r}
    is_directory <- function(x) {
      file.info(x)$isdir
    }
    is_readable <- function(x) {
      file.access(x, 4) == 0
    }
    ```

## Fun√ß√µes de *data frame*

Fun√ß√µes vetoriais s√£o √∫teis para extrair c√≥digo repetido em um verbo dplyr.
Mas muitas vezes voc√™ tamb√©m repetir√° os pr√≥prios verbos, especialmente em um *pipeline* grande.
Ao perceber que voc√™ est√° copiando e colando v√°rios verbos dplyr diversas vezes, voc√™ pode pensar em escrever uma fun√ß√£o de *data frame*.
As fun√ß√µes de *data frame* funcionam como verbos dplyr: elas pegam um *data frame* como primeiro argumento, alguns argumentos extras que dizem o que fazer com ele e retornam um *data frame* ou um vetor.

Para permitir que voc√™ escreva uma fun√ß√£o que use verbos dplyr, primeiro apresentaremos o desafio da indire√ß√£o (*indirection challenge*) e como voc√™ pode super√°-lo usando os sinais de chaves `{{ }}`.
Com essa teoria em m√£os, mostraremos v√°rios exemplos para ilustrar o que voc√™ pode fazer com ela.

### Indire√ß√£o e avalia√ß√£o organizada

Quando voc√™ come√ßa a escrever fun√ß√µes que usam verbos dplyr, voc√™ rapidamente se depara com o problema da indire√ß√£o.
Vamos ilustrar o problema com uma fun√ß√£o muito simples: `media_agrupada()`.
O objetivo desta fun√ß√£o √© calcular a m√©dia de `var_media` agrupada por `var_grupo`:

```{r}
media_agrupada <- function(df, var_grupo, var_media) {
  df |> 
    group_by(var_grupo) |> 
    summarize(mean(var_media))
}
```

Se tentarmos us√°-la, receberemos um erro:

```{r}
#| error: true
diamante |> media_agrupada(corte, quilate)
```

Para tornar o problema um pouco mais claro, podemos usar um *data frame* mais simples de exemplo:

```{r}
df <- tibble(
  var_media = 1,
  var_grupo = "g",
  grupo = 1,
  x = 10,
  y = 100
)

df |> media_agrupada(grupo, x)
df |> media_agrupada(grupo, y)
```

Independentemente de como chamamos `media_agrupada()` ele sempre faz `df |> group_by(var_grupo) |> summary(mean(var_media))`, em vez de `df |> group_by(grupo) |> summary(mean(x) )` ou `df |> group_by(grupo) |> summary(mean(y))`.
Este √© um problema de indire√ß√£o (*indirection*) e surge porque o dplyr usa **avalia√ß√£o organizada** (*tidy evaluation*) para permitir que voc√™ se refira aos nomes das vari√°veis ‚Äã‚Äãdentro do seu *data frame* sem qualquer tratamento especial.

A avalia√ß√£o organizada (*tidy evaluation*) √© √≥tima 95% das vezes porque torna suas an√°lises de dados muito concisas, j√° que voc√™ nunca precisa dizer de qual *data frame* vem uma vari√°vel; √© √≥bvio pelo contexto.
A desvantagem da avalia√ß√£o organizada surge quando queremos agrupar c√≥digos repetidos do tidyverse em uma fun√ß√£o.
Aqui precisamos de alguma maneira de dizer a `group_by()` e `summarize()` para n√£o tratar `group_var` e `mean_var` como o nome das vari√°veis, mas em vez disso procurar dentro delas a vari√°vel que realmente queremos usar.

A avalia√ß√£o organizada inclui uma solu√ß√£o para esse problema chamada **abra√ßar** (*embracing*) ü§ó.
Abra√ßar (*embracing*) uma vari√°vel significa envolv√™-la entre chaves para que (por exemplo) `var` se torne `{{ var }}`.
Abra√ßar uma vari√°vel diz ao dplyr para usar o valor armazenado dentro do argumento, n√£o o argumento como o nome literal da vari√°vel.
Uma maneira de lembrar o que est√° acontecendo √© pensar em `{{ }}` como olhar para dentro de um t√∫nel --- `{{ var }}` far√° uma fun√ß√£o dplyr olhar dentro de `var` em vez de procurar por uma vari√°vel chamada ` var`.

Ent√£o, para `media_agrupada()` funcionar, precisamos abra√ßar `var_grupo` e `var_media` com `{{ }}`:

```{r}
media_agrupada <- function(df, var_grupo, var_media) {
  df |> 
    group_by({{ var_grupo }}) |> 
    summarize(mean({{ var_media }}))
}

df |> media_agrupada(grupo, x)
```

Sucesso!

### Quando abra√ßar? {#sec-embracing}

Portanto, o principal desafio ao escrever fun√ß√µes de *data frame* √© descobrir quais argumentos precisam ser abra√ßados (*embraced*).
Felizmente, isso √© f√°cil porque voc√™ pode consultar a documenta√ß√£o üòÑ.
Existem dois termos a serem procurados nos documentos que correspondem aos dois subtipos mais comuns de avalia√ß√£o organizada (*tidy evaluation*):

-   **Mascaramento de dados** (*data-masking*): √© usado em fun√ß√µes como `arrange()`, `filter()` e `summarize()` que fazem calculos com vari√°veis.

-   **Selecionamento organizado** (*tidy-selection*): √© usado para fun√ß√µes como `select()`, `relocate()` e `rename()` que selecionam vari√°veis.

Sua intui√ß√£o sobre quais argumentos usam avalia√ß√£o organizada (*tidy evaluation*) deve ser boa para muitas fun√ß√µes comuns --- basta pensar se voc√™ pode calcular (por exemplo, `x + 1`) ou selecionar (por exemplo, `a:x`).

Nas se√ß√µes a seguir, exploraremos os tipos de fun√ß√µes √∫teis que voc√™ pode escrever depois de entender como abra√ßar (*embracing*) uma vari√°vel.

### Casos de uso mais comuns

Se voc√™ normalmente executa o mesmo conjunto de sumariza√ß√£o ao fazer a explora√ß√£o inicial de dados, considere agrup√°-los em uma fun√ß√£o auxiliar:

```{r}
sumario6 <- function(data, var) {
  data |> summarize(
    min = min({{ var }}, na.rm = TRUE),
    media = mean({{ var }}, na.rm = TRUE),
    mediana = median({{ var }}, na.rm = TRUE),
    max = max({{ var }}, na.rm = TRUE),
    n = n(),
    n_faltantes = sum(is.na({{ var }})),
    .groups = "drop"
  )
}

diamante |> sumario6(quilate)
```

(Sempre que voc√™ usa `summarize()` em uma fun√ß√£o auxiliar, achamos que √© uma boa pr√°tica definir `.groups = "drop"` para evitar a mensagem de aviso e deixar os dados em um estado desagrupado.)

O bom dessa fun√ß√£o √© que, como ela usa `summarize()`, voc√™ pode us√°-la em dados agrupados:

```{r}
diamante |> 
  group_by(corte) |> 
  sumario6(quilate)
```

Al√©m disso, uma vez que os argumentos da `summarize()` usam mascaramento de dados (*data-masking*), isso significa que o argumento `var` para a fun√ß√£o `sumario6()` tamb√©m usa mascaramento de dados (*data-masking*).
Isso significa que voc√™ tamb√©m pode sumarizar vari√°veis ‚Äã‚Äãcalculadas:

```{r}
diamante |> 
  group_by(corte) |> 
  sumario6(log10(quilate))
```

Para resumir m√∫ltiplas vari√°veis, voc√™ precisar√° esperar at√© @sec-across, onde aprender√° como usar `across()`.

Outra fun√ß√£o auxiliar usando `summarize()` popular √© uma vers√£o de `count()` que tamb√©m calcula propor√ß√µes:

```{r}
# https://twitter.com/Diabb6/status/1571635146658402309
conta_prop <- function(df, var, ordenar = FALSE) {
  df |>
    count({{ var }}, sort = ordenar) |>
    mutate(prop = n / sum(n))
}

diamante |> conta_prop(transparencia)
```

Esta fun√ß√£o tem tr√™s argumentos: `df`, `var` e `ordena`, e apenas `var` precisa ser abra√ßada (*embrancing*) porque √© passada para `count()` que usa mascaramento de dados (*data-masking*) para todas as vari√°veis.
Observe que usamos um valor padr√£o para `ordenar` para que, se o usu√°rio n√£o fornecer seu pr√≥prio valor, o padr√£o seja `FALSE`.

Ou talvez voc√™ queira encontrar os valores exclusivos ordenados de uma vari√°vel para um subconjunto de dados.
Em vez de fornecer uma vari√°vel e um valor para fazer a filtragem, permitiremos que o usu√°rio forne√ßa uma condi√ß√£o:

```{r}
unico_onde <- function(df, condicao, var) {
  df |> 
    filter({{ condicao }}) |> 
    distinct({{ var }}) |> 
    arrange({{ var }})
}

# Procura todos os destinos em Dezembro
voos |> unico_onde(mes == 12, destino)
```

Aqui abra√ßamos `condicao` porque √© passado para `filter()` e `var` porque √© passado para `distinct()` e `arrange()`.

Fizemos todos esses exemplos para usar um *data frame* como primeiro argumento, mas se voc√™ estiver trabalhando repetidamente com os mesmos dados, pode fazer sentido codific√°-los.
Por exemplo, a fun√ß√£o a seguir sempre funciona com o conjunto de dados de voos e sempre seleciona `data_hora`, `companhia_aerea` e `voo`, pois eles formam a chave prim√°ria composta (*compound primary key*) que permite identificar uma linha.

```{r}
subconjunto_voos <- function(linhas, colunas) {
  voos |> 
    filter({{ linhas }}) |> 
    select(data_hora, companhia_aerea, voo, {{ colunas }})
}
```

### Mascaramento de dados vs. sele√ß√£o organizada

√Äs vezes voc√™ deseja selecionar vari√°veis ‚Äã‚Äãdentro de uma fun√ß√£o que usa mascaramento de dados (*data-masking*).
Por exemplo, imagine que voc√™ deseja escrever uma fun√ß√£o `conta_faltantes()` que conte o n√∫mero de observa√ß√µes faltantes nas linhas.
Voc√™ pode tentar escrever algo como:

```{r}
#| error: true
conta_faltantes <- function(df, grupo_vars, x_var) {
  df |> 
    group_by({{ grupo_vars }}) |> 
    summarize(
      n_faltantes = sum(is.na({{ x_var }})),
      .groups = "drop"
    )
}

voos |> 
  conta_faltantes(c(ano, mes, dia), horario_saida)
```

Isto n√£o funciona, pois `group_by()` usa mascaramento de dados (*data-masking*), n√£o sele√ß√£o organizada (*tidy-selection*).
Podemos contornar esse problema usando a √∫til fun√ß√£o `pick()`, que permite usar a sele√ß√£o organizada (*tidy-selection*) dentro de fun√ß√µes de mascaramento de dados (*data-masking*):

```{r}
conta_faltantes <- function(df, grupo_vars, x_var) {
  df |> 
    group_by(pick({{ grupo_vars }})) |> 
    summarize(
      n_miss = sum(is.na({{ x_var }})),
      .groups = "drop"
  )
}

voos |> 
  conta_faltantes(c(ano, mes, dia), horario_saida)
```

Outro uso conveniente de `pick()` √© fazer uma tabela 2d de contagens.
Aqui contamos usando todas as vari√°veis ‚Äã‚Äãnas `linhas` e `colunas`, ent√£o usamos `pivot_wider()` para reorganizar as contagens em uma grade:

```{r}
# https://twitter.com/pollicipes/status/1571606508944719876
conta_wide <- function(data, linhas, colunas) {
  data |> 
    count(pick(c({{ linhas }}, {{ colunas }}))) |> 
    pivot_wider(
      names_from = {{ colunas }}, 
      values_from = n,
      names_sort = TRUE,
      values_fill = 0
    )
}

diamante |> conta_wide(c(transparencia, cor), corte)
```

Embora nossos exemplos tenham se concentrado principalmente no dplyr, a avalia√ß√£o organizada (*tidy-evaluation*) tamb√©m e usada pelo pacote tidyr, e se voc√™ olhar a documenta√ß√£o `pivot_wider()` voc√™ pode ver que `names_from` usa sele√ß√£o organizada (*tidy-selection*).

### Exerc√≠cios

1.  Usando os conjuntos de dados "voos" e "clima" do pacote dados, escreva uma fun√ß√£o que:

    1.  Encontra todos os voos que foram cancelados (ou seja, `is.na(horario_chegada)`) ou atrasados ‚Äã‚Äãpor mais de uma hora.

        ```{r}
        #| eval: false
        voos |> filtra_problematicos()
        ```

    2.  Conta o n√∫mero de voos cancelados e o n√∫mero de voos atrasados por um tempo maior que uma hora.

        ```{r}
        #| eval: false
        voos |> group_by(destino) |> summariza_problematicos()
        ```

    3.  Encontra todos os voos que foram cancelados ou atrasados ‚Äã‚Äãpor mais do que o n√∫mero de horas fornecido pelo usu√°rio:

        ```{r}
        #| eval: false
        voos |> filtra_problematicos(horas = 2)
        ```

    4.  Resuma o clima para calcular o m√≠nimo, a m√©dia e o m√°ximo de uma vari√°vel fornecida pelo usu√°rio:

        ```{r}
        #| eval: false
        clima |> summariza(temperatura)
        ```

    5.  Converte a vari√°vel fornecida pelo usu√°rio que usa o hor√°rio do rel√≥gio (por exemplo, `horario_saida`, `horario_chegada`, etc.) em um tempo decimal (ou seja, horas + (minutos/60)).

        ```{r}
        #| eval: false
        voos |> horario_padronizado(saida_programada)
        ```

2.  Para cada uma das fun√ß√µes a seguir, liste todos os argumentos que usam avalia√ß√£o organizada (*tidy-evaluation) e descreva se eles usam mascaramento de dados (*data-masking*) ou sele√ß√£o organizada (tidy-selection): `distinct()`, `count()`, `group_by()`, `rename_with()`, `slice_min()`, `slice_amostra()`.

3.  Generalize a fun√ß√£o a seguir para que voc√™ possa fornecer qualquer n√∫mero de vari√°veis ‚Äã‚Äãpara a fun√ß√£o contar.

    ```{r}
    conta_prop <- function(df, var, ordenar = FALSE) {
      df |>
        count({{ var }}, sort = ordenar) |>
        mutate(prop = n / sum(n))
    }
    ```

## Fun√ß√µes de plotagem

Ao inv√©s de retornar um *data frame*, voc√™ pode querer retornar um gr√°fico.
Felizmente, voc√™ pode usar as mesmas t√©cnicas com ggplot2, porque `aes()` √© uma fun√ß√£o de mascaramento de dados (*data-masking*).
Por exemplo, imagine que voc√™ est√° fazendo muitos histogramas:

```{r}
#| fig-show: hide
diamante |> 
  ggplot(aes(x = quilate)) +
  geom_histogram(binwidth = 0.1)

diamante |> 
  ggplot(aes(x = quilate)) +
  geom_histogram(binwidth = 0.05)
```

N√£o seria bom se voc√™ pudesse agrupar isso em uma fun√ß√£o de histograma?
Isso √© muito f√°cil quando voc√™ sabe que `aes()` √© uma fun√ß√£o de mascaramento de dados (*data-masking*) e voc√™ precisa abra√ßar (*embrace*):

```{r}
#| fig-alt: |
#|   Um histograma de quilates de diamantes, variando de 0 a 5, mostrando um formato unimodal, 
#|   com distribui√ß√£o enviesada √† direita com um pico entre 0 a 1 quilate.

histograma <- function(df, var, binwidth = NULL) {
  df |> 
    ggplot(aes(x = {{ var }})) + 
    geom_histogram(binwidth = binwidth)
}

diamante |> histograma(quilate, 0.1)
```

Observe que `histograma()` retorna um gr√°fico ggplot2, o que significa que voc√™ ainda pode adicionar componentes adicionais se desejar.
Apenas lembre-se de mudar de `|>` para `+`:

```{r}
#| fig.show: hide
diamante |> 
  histograma(quilate, 0.1) +
  labs(x = "Tamanho (em quilate)", y = "N√∫mero de diamantes")
```

### Mais vari√°veis

√â simples adicionar mais vari√°veis ‚Äã‚Äã√† mistura.
Por exemplo, talvez voc√™ queira uma maneira f√°cil de verificar se um conjunto de dados √© linear ou n√£o, sobrepondo uma linha suave e uma linha reta:

```{r}
#| fig-alt: |
#|   Gr√°fico de dispers√£o de altura versus massa de personagens de StarWars mostrando uma reala√ß√£o positiva 
#|   . Uma curva suave da rela√ß√£o √© tra√ßada em vermelho e 
#|   a linha de melhor ajuste √© plotada em azul.

# https://twitter.com/tyler_js_smith/status/1574377116988104704
valida_linearidade <- function(df, x, y) {
  df |>
    ggplot(aes(x = {{ x }}, y = {{ y }})) +
    geom_point() +
    geom_smooth(method = "loess", formula = y ~ x, color = "red", se = FALSE) +
    geom_smooth(method = "lm", formula = y ~ x, color = "blue", se = FALSE) 
}

dados_starwars |> 
  filter(massa < 1000) |> 
  valida_linearidade(massa, altura)
```

Ou talvez voc√™ queira uma alternativa aos gr√°ficos de dispers√£o coloridos para conjuntos de dados muito grandes, onde a plotagem excessiva √© um problema:

```{r}
#| fig-alt: |
#|   Gr√°fico hexagonal de pre√ßo versus quilate de diamantes mostrando uma rela√ß√£o positiva. 
#|   Existem mais diamantes com menos de 2 quilates do que com mais de 2 quilates.

# https://twitter.com/ppaxisa/status/1574398423175921665
grafico_hex <- function(df, x, y, z, bins = 20, fun = "mean") {
  df |> 
    ggplot(aes(x = {{ x }}, y = {{ y }}, z = {{ z }})) + 
    stat_summary_hex(
      aes(color = after_scale(fill)), # faz border igual ao preenchimento
      bins = bins, 
      fun = fun,
    )
}

diamante |> grafico_hex(quilate, preco, profundidade)
```

### Combinando com outros tidyverse

Algumas das fun√ß√µes auxiliares mais √∫teis combinam uma pitada de manipula√ß√£o de dados com ggplot2.
Por exemplo, se voc√™ quiser fazer um gr√°fico de barras verticais onde voc√™ classifica automaticamente as barras em ordem de frequ√™ncia usando a fun√ß√£o `fct_infreq()`.
Como o gr√°fico de barras √© vertical, tamb√©m precisamos inverter a ordem normal para obter os valores mais altos no topo:

```{r}
#| fig-alt: |
#|   Gr√°fico de barras de transpar√™ncia de diamantes, onde a clareza est√° no eixo y e as contagens
#|   est√£o no eixo x, e as barras s√£o ordenadas em ordem de frequ√™ncia: SI1, 
#|   VS2, SI2, VS1, VVS2, VVS1, IF, I1.

barras_ordenadas <- function(df, var) {
  df |> 
    mutate({{ var }} := fct_rev(fct_infreq({{ var }})))  |>
    ggplot(aes(y = {{ var }})) +
    geom_bar()
}

diamante |> barras_ordenadas(transparencia)
```

Temos que usar um novo operador aqui, `:=` (comumente chamado de "operador morsa"), porque estamos gerando o nome da vari√°vel com base nos dados fornecidos pelo usu√°rio.
Os nomes das vari√°veis ‚Äã‚Äãficam no lado esquerdo de `=`, mas a sintaxe do R n√£o permite nada √† esquerda de `=`, exceto um √∫nico nome literal.
Para contornar este problema, usamos o operador especial `:=` que a avalia√ß√£o organizada (*tidy evaluation*) trata exatamente da mesma maneira que `=`..

Ou talvez voc√™ queira facilitar o desenho de um gr√°fico de barras apenas para um subconjunto de dados:

```{r}
#| fig-alt: |
#|   Gr√°fico de barras de clareza de diamantes. O mais comum √© SI1, depois SI2 e depois 
#|   VS2, depois VS1, depois VVS2, depois VVS1, depois I1 e, por √∫ltimo, IF.

barras_condicionais <- function(df, condicao, var) {
  df |> 
    filter({{ condicao }}) |> 
    ggplot(aes(x = {{ var }})) + 
    geom_bar()
}

diamante |> barras_condicionais(corte == "Bom", transparencia)
```

Voc√™ tamb√©m pode ser criativo e exibir resumos de dados de outras maneiras.
Voc√™ pode encontrar um aplicativo interessante em <https://gist.github.com/GShotwell/b19ef520b6d56f61a830fabb3454965b>; ele usa os r√≥tulos dos eixos para exibir o valor mais alto.
√Ä medida que voc√™ aprende mais sobre o ggplot2, o poder de suas fun√ß√µes continuar√° a aumentar.

Terminaremos com um caso mais complicado: rotular os gr√°ficos que voc√™ cria.

### R√≥tulos

Lembra da fun√ß√£o de histograma que mostramos anteriormente?

```{r}
histograma <- function(df, var, binwidth = NULL) {
  df |> 
    ggplot(aes(x = {{ var }})) + 
    geom_histogram(binwidth = binwidth)
}
```

N√£o seria bom se pud√©ssemos rotular a sa√≠da com a vari√°vel e a largura do intervalo que foi usada?
Para fazer isso, teremos que nos aprofundar na avalia√ß√£o organizada (*tidy evaluation*) e usar uma fun√ß√£o do pacote sobre a qual ainda n√£o falamos: rlang.
rlang √© um pacote de baixo n√≠vel usado por quase todos os outros pacotes do tidyverse porque implementa a avalia√ß√£o organizada (*tidy evaluation*) (bem como muitas outras ferramentas √∫teis).

Para resolver o problema de rotulagem podemos usar `rlang::englue()`.
Isso funciona de forma semelhante a `str_glue()`, ent√£o qualquer valor colocado em `{ }` ser√° inserido na string.
Mas tamb√©m entende `{{ }}`, que insere automaticamente o nome apropriado da vari√°vel:

```{r}
#| fig-alt: |
#|   Um histograma de quilates de diamantes, variando de 0 a 5, mostrando um formato unimodal, 
#|   com distribui√ß√£o enviesada √† direita com um pico entre 0 a 1 quilate

histograma <- function(df, var, binwidth) {
  rotulo <- rlang::englue("Um histograma da vari√°vel {{var}} com agrupamento de {binwidth}")
  
  df |> 
    ggplot(aes(x = {{ var }})) + 
    geom_histogram(binwidth = binwidth) + 
    labs(title = rotulo)
}

diamante |> histograma(quilate, 0.1)
```

Voc√™ pode usar a mesma abordagem em qualquer outro lugar onde deseja fornecer uma string em um gr√°fico ggplot2.

### Exerc√≠cios

Crie uma fun√ß√£o de plotagem rica implementando gradualmente cada uma das etapas abaixo:

1.  Desenhe um gr√°fico de dispers√£o dado o conjunto de dados e as vari√°veis ‚Äã‚Äã`x` e `y`.

2.  Adicione uma linha de melhor ajuste (*best fit*) (ou seja, um modelo linear sem erros padr√£o).

3.  Adicione um t√≠tulo.

## Estilos

R n√£o se importa com o nome de sua fun√ß√£o ou argumentos, mas os nomes fazem uma grande diferen√ßa para as pessoas.
Idealmente, o nome da sua fun√ß√£o ser√° curto, mas evocar√° claramente o que a fun√ß√£o faz.
Isso √© dif√≠cil!
Mas √© melhor ser claro do que curto, pois o preenchimento autom√°tico do RStudio facilita a digita√ß√£o de nomes longos.

Geralmente, os nomes das fun√ß√µes devem ser verbos e os argumentos devem ser substantivos.
Existem algumas exce√ß√µes: substantivos s√£o aceit√°veis ‚Äã‚Äãse a fun√ß√£o calcular um substantivo muito conhecido (ou seja, `media()` √© melhor que `calcular_media()`), ou acessar alguma propriedade de um objeto (ou seja, `coef()` √© melhor do que `obter_coeficientes()`).
Use seu bom senso e n√£o tenha medo de renomear uma fun√ß√£o se descobrir um nome melhor mais tarde.

```{r}
#| eval: false

# Muito curto
f()

# N√£o √© verbo, nem descritivo
minha_funcao_maravilhosa()

# Longo, mas claro
adicionar_faltantes()
agrupar_anos()
```

R tamb√©m n√£o se importa em como voc√™ usa o espa√ßo em branco em suas fun√ß√µes, mas os futuros leitores o far√£o.
Continue seguindo as regras do @sec-workflow-style.
Al√©m disso, `funcao()` deve sempre ser seguida por chaves (`{}`), e o conte√∫do deve ser recuado por dois espa√ßos adicionais.
Isso torna mais f√°cil ver a hierarquia em seu c√≥digo, percorrendo a margem esquerda.

```{r}
# Faltando dois espa√ßos em branco
densidade <- function(cor, facetas, agrupamento = 0.1) {
diamante |> 
  ggplot(aes(x = quilate, y = after_stat(density), color = {{ cor }})) +
  geom_freqpoly(binwidth = agrupamento) +
  facet_wrap(vars({{ facetas }}))
}

# *Pipe* identado incorretamente
densidade <- function(cor, facetas, agrupamento = 0.1) {
  diamante |> 
  ggplot(aes(x = carat, y = after_stat(density), color = {{ cor }})) +
  geom_freqpoly(binwidth = agrupamento) +
  facet_wrap(vars({{ facets }}))
}
```

Como voc√™ pode ver, recomendamos colocar espa√ßos extras dentro de `{{ }}`.
Isso torna muito √≥bvio que algo incomum est√° acontecendo.

### Exerc√≠cios

1.  Leia o c√≥digo-fonte de cada uma das duas fun√ß√µes a seguir, descubra o que elas fazem e, em seguida, pense em nomes melhores.

    ```{r}
    f1 <- function(string, prefixo) {
      str_sub(string, 1, str_length(prefixo)) == prefixo
    }

    f3 <- function(x, y) {
      rep(y, length.out = length(x))
    }
    ```

2.  Pegue uma fun√ß√£o que voc√™ escreveu recentemente e gaste 5 minutos pensando em um nome melhor para ela e seus argumentos.

3.  Explique por que `norm_r()`, `norm_d()` etc. seriam melhores que `rnorm()`, `dnorm()`.
    Defenda o contr√°rio.
    Como voc√™ poderia deixar os nomes ainda mais claros?

## Resumo

Neste cap√≠tulo, voc√™ aprendeu como escrever fun√ß√µes para tr√™s cen√°rios √∫teis: criar um vetor, criar um *data frame* ou criar um gr√°fico.
Ao longo do caminho, voc√™ viu muitos exemplos, que esperamos que tenham come√ßado a estimular sua criatividade, e lhe deram algumas ideias de onde as fun√ß√µes podem ajudar em seu c√≥digo de an√°lise.

Mostramos apenas o m√≠nimo para come√ßar a usar as fun√ß√µes e h√° muito mais para aprender.
Alguns lugares para aprender mais s√£o:

-   Para saber mais sobre programa√ß√£o e avalia√ß√£o organizada (*tidy evaluation*), veja receitas √∫teis em [programando com dplyr](https://dplyr.tidyverse.org/articles/programming.html) e [programando com tidyr](https://tidyr.tidyverse.org/articles/programming.html) e para aprender mais sobre a teoria em [O que √© mascaramento de dados e por que preciso disso {{?](https://rlang.r-lib.org/reference/topic-data-mask.html).
-   Para saber mais sobre como reduzir a duplica√ß√£o no c√≥digo ggplot2, leia o cap√≠tulo [Programando com ggplot2](https://ggplot2-book.org/programming.html){.uri} do livro ggplot2.
-   Para obter mais conselhos sobre estilo de fun√ß√£o, consulte o [guia de estilo do tidyverse](https://style.tidyverse.org/functions.html){.uri}.

No pr√≥ximo cap√≠tulo, mergulharemos na itera√ß√£o (*iteration*), que oferece mais ferramentas para reduzir a duplica√ß√£o de c√≥digo.
