# Dado hierárquico {#sec-rectangling}

```{r}
#| echo: false

source("_common.R")
```

## Introdução

Neste capítulo, você aprenderá a arte da **representação retangular** dos dados (*rectangling*): pegar um dado que é fundamentalmente hierárquico ou baseado em uma estrutura de árvore (*tree-like*) e convertê-lo em um *data frame* retangular, composto por linhas e colunas.
Isto é importante porque dados hierárquicos são surpreendentemente comuns, especialmente quando se trabalha com dados vindos da web.

Para aprender sobre representação retangular, você precisa aprender primeiro sobre listas, que são estruturas de dados que tornam os dados hierárquicos possíveis.
Depois, você aprenderá sobre duas funções críticas do tidyr: `tidyr::unnest_longer()` e `tidyr::unnest_wider()`.
Iremos então mostrar alguns estudos de caso, aplicando estas funções simples diversas vezes para resolver problemas reais.
Concluiremos falando sobre JSON, a fonte mais frequente de conjuntos de dados hierárquicos e um formato comum para intercambio de dados na web.

### Pré-requisitos

Neste capítulo, usaremos várias funções do tidyr, um pacote central do tidyverse.
Usaremos também o pacote repurrrsive para nos fornecer alguns conjuntos de dados interessantes para praticar a representação retangular e concluiremos usando o pacote jsonlite para importar arquivos JSON para o R como listas.

```{r}
#| label: setup
#| message: false

library(tidyverse)
library(repurrrsive)
library(jsonlite)
```

## Listas

Até agora você trabalhou com *data frames* que continham vetores simples como inteiros, números, caracteres, data_hora e fatores.
Estes vetores são simples pois são homogêneos: cada elemento tem o mesmo tipo de dado.
Se você quiser armazenar elementos de diferentes tipos no mesmo vetor, você precisará de uma **lista**, que pode ser criada com a função `list()`:

```{r}
x1 <- list(1:4, "a", TRUE)
x1
```

Em geral, é conveniente nomear os componentes ou **elementos** de uma lista, o que pode ser feito da mesma forma que nomeamos colunas de um *tibble*:

```{r}
x2 <- list(a = 1:2, b = 1:3, c = 1:4)
x2
```

Até para estas listas simples, é necessário um espaço razoável para exibi-las no Console.
Uma alternativa é usar `str()`, que gera uma visualização compacta da e**str**utura, tirando o foco de seu contéudo:

```{r}
str(x1)
str(x2)
```

Como você pode ver, `str()` mostra cada elemento da lista em uma linha própria.
Esta função mostra o nome, quando presente, seguido de uma abreviação do tipo e então os primeiros valores.

### Hierarquia

Listas podem conter qualquer tipo de objeto, incluindo outras listas.
Isto as tornam adequadas para representar estruturas hierárquicas (*tree-like*):

```{r}
x3 <- list(list(1, 2), list(3, 4))
str(x3)
```

Isto é notoriamente diferente de `c()`, que gera um vetor achatado (*flat*):

```{r}
c(c(1, 2), c(3, 4))

x4 <- c(list(1, 2), list(3, 4))
str(x4)
```

Conforme as listas se tornam mais complexas, `str()` se torna mais útil, pois permite que você veja a hierarquia rapidamente:

```{r}
x5 <- list(1, list(2, list(3, list(4, list(5)))))
str(x5)
```

Conforme as listas aumentam ainda mais e se tornam ainda mais complexas, `str()` pode começar a deixar de ser útil e você precisará mudar para a `View()`[^rectangling-1].
A @fig-view-collapsed mostra o resultado da chamada de `View(x5)`. O visualizador começa mostrando o nível mais alto da lista, mas você pode expandir interativamente qualquer componente para ver mais, como na @fig-view-expand-1. O RStudio também lhe mostra o código que você precisaria para acessar aquele elemento, como na @fig-view-expand-2. Retornaremos a como este código funciona na @sec-subset-one.

[^rectangling-1]: Esta é uma funcionalidade do RStudio.

```{r}
#| label: fig-view-collapsed
#| fig.cap: >
#|   A visualização do RStudio permite que você explore interativamente listas complexas.  
#|   O visualizador inicia mostrando apenas os primeiros níveis da lista.
#| fig.alt: >
#|   Uma captura de tela do RStudio mostrando o visualizador de listas. Mostra os
#|   dois componentes filhos de x5: o primeiro elemento é um vetor *double* e
#|   o segundo é uma lista. Um triangulo apontando para a direita indica que
#|   o segundo elemento possue em si elementos filhos mas que você não consegue ver.
#| echo: false
#| out-width: NULL
knitr::include_graphics("screenshots/View-1.png", dpi = 220)
```

```{r}
#| label: fig-view-expand-1
#| fig.cap: >
#|   Clicando no triangulo  apontado para a direita, o elemento de lista se expande 
#|   e então você pode ver seus elementos filhos.
#| fig.alt: >
#|   Outra captura de tela do visualizador de listas com os elements do segundo elemento de
#|   x5. Ele também tem dois elementos filhos, um vetor *double* e outra
#|   lista.
#| echo: false
#| out-width: NULL
knitr::include_graphics("screenshots/View-2.png", dpi = 220)
```

```{r}
#| label: fig-view-expand-2
#| fig.cap: >
#|   Você pode repetir esta operação quantas vezes quiser até 
#|   chegar aos dados desejados. Note no canto inferior esquerdo: se você clicar
#|   em um elemento da lista, o RStudio lhe fornece o código necessário para acessar tal elemento
#|   neste caso `x5[[2]][[2]][[2]]`.
#| fig.alt: >
#|   Outra captura de tela com o elemento neto de x5 expandido
#|   para ver seus dois filhos, novamente um vetor *double* e uma lista.
#| echo: false
#| out-width: NULL
knitr::include_graphics("screenshots/View-3.png", dpi = 220)
```

### List-columns

Listas também podem estar presentes em um *tibble*, quando isto acontece as chamamos de colunas-lista (*list-columns*).
*List-columns* são úteis porque elas permitem que você coloque objetos em um *tibble* que normalmente não pertenceriam a ele.
Em particular, *list-columns* são muito usadas no ecosistema [tidymodels](https://www.tidymodels.org), pois permitem que você armazene coisas como saída de modelos ou amostras (*resamples*) em um *data frame*.

Aqui está um simples exemplo de uma *list-column*:

```{r}
df <- tibble(
  x = 1:2, 
  y = c("a", "b"),
  z = list(list(1, 2), list(3, 4, 5))
)
df
```

Não há nada de especial nesta lista dentro de um *tibble*; se comportando como qualquer outra coluna:

```{r}
df |> 
  filter(x == 1)
```

Trabalhar com *list-column* é mais difícil, mas isto se dá porque trabalhar com listas é difícil de modo geral; voltaremos a este assunto no @sec-iteration.
Neste capítulo, nos concetraremos em desaninhar (*unnest*) as colunas-lista em variáveis regulares para que você possa usar tuas ferramentas já existentes nelas.

O método de exibição padrão é um resumo grosseiro de seus conteúdos.
A *list-column* poderia ser arbitrariamente complexa, portanto não há um jeito fácil de exibi-las ("printa-las").
Se quiser visualizá-la, você precisará extrair apenas a *list-column* em questão e aplicar uma das técnicas que aprendeu acima, como `df |> pull(z) |> str()` ou `df |> pull(z) |> View()`.

::: callout-note
## R base

É possível colocar uma lista em uma coluna de um *data frame*, mas é muito mais complicado, porque `data.frame()` trata uma lista como uma *list-column*:

```{r}
data.frame(x = list(1:3, 3:5))
```

Você pode forçar `data.frame()` a tratar uma lista como uma lista de linhas envolvendo-a com a função `I()`, mas o resultado não gera uma exibição muito boa:

```{r}
data.frame(
  x = I(list(1:2, 3:5)), 
  y = c("1, 2", "3, 4, 5")
)
```

É mais fácil usar *list-columns* com *tibbles*, pois a função `tibble()` trata listas como vetores e o método de exibição foi projetado tendo listas em mente.
:::

## Desaninhando (*unnesting*)

Agora que você aprendeu o básico sobre listas e *list-columns*, vamos explorar como você pode transformá-las novamente em linhas e colunas regulares.
Aqui usaremos uma amostra de dados simples para que você entenda a ideia básica; na próxima seção mudaremos para dados reais.

*List-columns* tendem a aparecer em duas formas básicas: nomeadas (*named*) e não nomeadas (*unnamed*).
Quando os elementos filhos são **nomeados**, eles tendem a ter o mesmo nome em todas as linhas.
Por exemplo, em `df1`, cada elemento da *list-column* `y` tem dois elementos nomeados `a` e `b`.
*List-columns* nomeadas naturalmente se desaninham em colunas: cada elemento nomeado se torna uma nova coluna nomeada.

```{r}
df1 <- tribble(
  ~x, ~y,
  1, list(a = 11, b = 12),
  2, list(a = 21, b = 22),
  3, list(a = 31, b = 32),
)
```

Quando os elementos filhos são **não nomeados**, o número de elementos tendem a variar de linha para linha.
Por exemplo, em `df2`, os elementos da *list-column* `y` são não nomeados e variam em tamanhos de um até três.
*List-columns* não nomeadas se desaninham naturalmente em linhas: você terá uma linha para cada elemento filho.

```{r}

df2 <- tribble(
  ~x, ~y,
  1, list(11, 12, 13),
  2, list(21),
  3, list(31, 32),
)
```

tidyr fornece duas funções para estes dois casos: `unnest_wider()` e `unnest_longer()`.
As seções seguintes explicam como elas funcionam.

### `unnest_wider()`

Quado cada linha tem o mesmo número de elementos com o mesmo nome, como em `df1`, é natural colocar cada elemento em sua própria coluna com `unnest_wider()`:

```{r}
df1 |> 
  unnest_wider(y)
```

Por padrão, os nomes das novas colunas vem exclusivamente dos nomes dos elementos da lista, mas você pode usar o argumento `names_sep` para solicitar que o nome da coluna seja combinado com o nome do elemento.
Isto é útil para remover ambiguidades de nomes repetidos.

```{r}
df1 |> 
  unnest_wider(y, names_sep = "_")
```

### `unnest_longer()`

Quando cada linha contiver uma lista não nomeada, é mais natural colocar cada elemento em sua própria linha com `unnest_longer()`:

```{r}
df2 |> 
  unnest_longer(y)
```

Note como `x` está duplicado para cada elemento dentro de `y`: temos uma linha de saída para cada elemento dentro da *list-column*.
Mas o que acontece se algum dos elementos estiver vazio, como no exemplo a seguir?

```{r}
df6 <- tribble(
  ~x, ~y,
  "a", list(1, 2),
  "b", list(3),
  "c", list()
)
df6 |> unnest_longer(y)
```

Temos zero linhas na saída, portanto a linha efetivamente desaparece.
Se quiser preservar esta linha, adicionando `NA` em `y`, defina `keep_empty = TRUE`.

### Tipos inconsistentes

O que acontece se você desaninhar uma *list-column* que contém diferentes tipos de vetores?
Por exemplo, veja o seguinte conjunto de dados onde a *list-column* `y` contém dois números, um caractere e um lógico, a qual você normalmente não pode juntar em uma única coluna.

```{r}
df4 <- tribble(
  ~x, ~y,
  "a", list(1),
  "b", list("a", TRUE, 5)
)
```

`unnest_longer()` sempre mantém o conjunto de colunas imutável, enquanto muda o número de linhas.
Então, o que acontece?
Como que `unnest_longer()` produz cinco linhas e ao mesmo tempo mantém tudo em `y`?

```{r}
df4 |> 
  unnest_longer(y)
```

Como você pode ver, a saída contém uma *list-column*, mas cada elemento da *list-column* contém um único elemento.
Como `unnest_longer()` não pode encontrar um tipo de vetor comum, ela mantém os tipos originais em uma *list-column*.
Você pode estar se perguntando se isso viola o mandamento de que cada elemento de uma coluna deve ser do mesmo tipo.
Não: cada elemento é uma lista, mesmo que os conteúdos sejam de tipos diferentes.

Lidar com tipos inconsistentes é desafiador e os detalhes dependem da natureza precisa do problema e dos seus objetivos, mas você provavelmente precisará de ferramentas do @sec-iteration.

### Outras funções

O tidyr tem algumas outras funções de representação retangular que não iremos cobrir neste livro:

-   `unnest_auto()` automaticamente escolhe entre `unnest_longer()` e `unnest_wider()` baseado na estrutura da *list-column*. Esta função é ótima para uma exploração rápida, mas no fim das contas é uma má ideia pois não força você a entender como seus dados estão estruturados e torna teu código mais difícil de entender.
-   `unnest()` expande tanto linhas quanto colunas. É muito poderosa quando você tem uma *list-column* que contém uma estrutura 2d como um *data frame*, algo que você não verá neste livro, mas você deve encontrar se usar o ecosistema [tidymodels](https://www.tmwr.org/base-r.html#combining-base-r-models-and-the-tidyverse).

É bom conhecer estas funções pois você pode encontrá-las em códigos de outras pessoas ou enfrentar você mesmo desafios mais raros de representação retangular.

### Exercícios

1.  O que acontece quando você utiliza `unnest_wider()` com *list-columns* não nomeadas como em `df2`?
    Qual argumento é necessário agora?
    O que acontece com valores faltantes (*missing*)?

2.  O que acontece quando você utiliza `unnest_longer()` com *list-columns* nomeadas como em `df1`?
    Qual informação adicional você recebe na saída?
    Como você pode suprimir estes detalhes extras?

3.  De tempos em tempos, você encontra *data frames* com várias *list-columns* com valores alinhados.
    Por exemplo, no *data frame* seguinte, os valores de `y`e `z` estão alinhados (ex: `y` e `z` sempre terão o mesmo tamanho dentro de uma linha e o primeiro valor de `y` corresponde ao primeiro valor de `z`).
    O que acontece quando você executa a função `unnest_longer()` duas vezes neste *data frame*?
    Como você pode preservar a relação entre `x` e `y`?
    (Dica: leia atentamente a documentação).

    ```{r}
    df4 <- tribble(
      ~x, ~y, ~z,
      "a", list("y-a-1", "y-a-2"), list("z-a-1", "z-a-2"),
      "b", list("y-b-1", "y-b-2", "y-b-3"), list("z-b-1", "z-b-2", "z-b-3")
    )
    ```

## Estudos de casos

A principal diferença entre os exemplos simples que usamos acima e o de dados reais, é que os dados reais tipicamente contém vários níveis de aninhamento (*nesting*) que requerem o uso consecutivo de `unnest_longer()` e/ou `unnest_wider()`.
Para mostrar isto em ação, esta seção faz uso de três desafios de representação retangular, usando conjunto de dados do pacote repurrrsive.

### Dados bem largos (*wide data*)

Começaremos com `gh_repos`.
Esta é uma lista que contém dados sobre uma coleção de repositórios do GitHub obtidos usando a API do GitHub. É uma lista aninhada em vários níveis, por isso é difícil de mostrar sua estrutura neste livro; nós recomendamos que você a explore por conta própria usando `View(gh_repos)` antes de continuar.

`gh_repos` é uma lista, mas nossas ferramentas trabalham com *list-columns*, então iremos começar colocando-a em um *tibble*.
Chamaremos esta coluna de `json` por razões que veremos mais tarde.

```{r}
repos <- tibble(json = gh_repos)
repos
```

Este *tibble* contém 6 linhas, uma linha para cada elemento filho de `gh_repos`.
Cada linha contém uma lista não nomeada com 26 ou 30 linhas.
Como elas são não nomeadas, começaremos com `unnest_longer()` para colocar cada filho em sua própria linha:

```{r}
repos |> 
  unnest_longer(json)
```

À primeira vista, pode parecer que não melhoramos a situação: apesar de termos mais linhas (176 ao invés de 6), cada elemento de `json` ainda é uma lista.
Entretando, há uma importante diferença: agora, cada elemento é uma lista **nomeada**, então podemos usar `unnest_wider()` para colocar cada elemento em sua própria coluna:

```{r}
repos |> 
  unnest_longer(json) |> 
  unnest_wider(json) 
```

Isto fucionou, mas o resultado ficou um pouco estranho: Existem tantas colunas que o *tibble* nem exibe todas elas!
Podemos ver todas as colunas com `names()`; e aqui vemos as primeiras 10:

```{r}
repos |> 
  unnest_longer(json) |> 
  unnest_wider(json) |> 
  names() |> 
  head(10)
```

Vamos extrair algumas que parecem interessantes:

```{r}
repos |> 
  unnest_longer(json) |> 
  unnest_wider(json) |> 
  select(id, full_name, owner, description)
```

Você pode usar isso para entender como o `gh_repos` foi estruturado: cada elemento filho era um usuário do GitHub contendo uma lista de até 30 repositórios do GitHub que eles criaram.

`owner` é uma outra *list-column*, e uma vez que contém uma lista nomeada, podemos usar `unnest_wider()` para obter seus valores:

```{r}
#| error: true
repos |> 
  unnest_longer(json) |> 
  unnest_wider(json) |> 
  select(id, full_name, owner, description) |> 
  unnest_wider(owner)
```

Uh uh, esta *list-column* também contém uma coluna `id` e não podemos ter duas colunas `id` no mesmo *data frame*.
Conforme sugerido, vamos usar `names_sep` para resolver este problema:

```{r}
repos |> 
  unnest_longer(json) |> 
  unnest_wider(json) |> 
  select(id, full_name, owner, description) |> 
  unnest_wider(owner, names_sep = "_")
```

Isto nos dá um outro conjunto de dados largo (*wide*), mas você pode perceber que `owner` (pessoa proprietária) parece conter muitos dados adicionais sobre a pessoa "proprietária" do repositório.

### Dados relacionais

Dados aninhados (*nested*) muitas vezes são usados para representar dados que normalmente estariam espalhados por vários *data frames*.
Por exemplo, veja `got_chars` que contém dados sobre os personagens (*characters*) que aparecem nos livros e série de TV *Game of Thrones*.
Assim como `gh_repos`, ela também é uma lista, então começamos transformado-a em uma *list-column* de um *tibble*:

```{r}
chars <- tibble(json = got_chars)
chars
```

A coluna `json` contém elementos nomeados, estão vamos começar alargando-os (*widening*):

```{r}
chars |> 
  unnest_wider(json)
```

E selecionando algumas colunas para lermos mais facilmente:

```{r}
characters <- chars |> 
  unnest_wider(json) |> 
  select(id, name, gender, culture, born, died, alive)
characters
```

Este conjunto de dados também contém várias *list-columns*:

```{r}
chars |> 
  unnest_wider(json) |> 
  select(id, where(is.list))
```

Vamos explorar a coluna `titles` (títulos).
É uma *list-column* não nomeada, então desaninharemos em linhas:

```{r}
chars |> 
  unnest_wider(json) |> 
  select(id, titles) |> 
  unnest_longer(titles)
```

Você esperaria ver estes dados em um tabela própria, pois seria mais fácil uní-los com os dados dos personagens conforme necessário.
Vamos fazer isso, o que requer um pouco de limpeza: removendo as linhas que contém *strings* vazias e renomeando `titles` para `title` já que cada linha agora contém um único título.

```{r}
titles <- chars |> 
  unnest_wider(json) |> 
  select(id, titles) |> 
  unnest_longer(titles) |> 
  filter(titles != "") |> 
  rename(title = titles)
titles
```

Você poderia imaginar criar uma tabela como esta para cada *list-column* e então usar uniões (*joins*) para combiná-las com os dados dos personagens conforme você achar necessário.

### Profundamente aninhados (*deeply nested*)

Concluiremos estes estudos de casos com uma *list-column* que é profundamente aninhada e requer repetidas rodadas de `unnest_wider()` e `unnest_longer()` para ser desvendada: `gmaps_cities`.
Este é um *tibble* de duas colunas contendo cinco nomes de cidades e o resultado da [API de geolocalização](https://developers.google.com/maps/documentation/geocoding) do *Google* para determinar suas localizações:

```{r}
gmaps_cities
```

`json` é uma *list-column* nomeada, portanto iremos começar com `unnest_wider()`:

```{r}
gmaps_cities |> 
  unnest_wider(json)
```

Isto nos retorna `status` e `results`.
Iremos remover a coluna status já que são todos `OK`; em uma análise real, você também iria capturar todas as linhas onde `status != "OK"` e entender o que deu errado.
`results` é uma lista não nomeada, com um ou dois elementos (veremos porque em breve), portanto iremos desaninhá-la em linhas:

```{r}
gmaps_cities |> 
  unnest_wider(json) |> 
  select(-status) |> 
  unnest_longer(results)
```

Agora `results` é uma lista nomeada, então usaremos `unnest_wider()`:

```{r}
locations <- gmaps_cities |> 
  unnest_wider(json) |> 
  select(-status) |> 
  unnest_longer(results) |> 
  unnest_wider(results)
locations
```

Agora podemos ver porque duas cidades tinham dois resultados: Washington correspondeu ao estado Washington e Washington, DC e Arlington correspondeu a Arlington, Virginia e Arlington, Texas.

Há vários lugares que podemos ir a partir daqui.
Poderíamos querer determinar a localização exata da localidade correspondente, a qual é armazenada na *list-column* `geometry`:

```{r}
locations |> 
  select(city, formatted_address, geometry) |> 
  unnest_wider(geometry)
```

Isto nos dá novos `bounds` (uma região retangular) e `location` (um ponto).
Podemos desaninhar `location` para vermos a latitude (`lat`) e longitude (`lng`):

```{r}
locations |> 
  select(city, formatted_address, geometry) |> 
  unnest_wider(geometry) |> 
  unnest_wider(location)
```

Alguns passos adicionais são necessários para extrairmos os *bounds*:

```{r}
locations |> 
  select(city, formatted_address, geometry) |> 
  unnest_wider(geometry) |> 
  # foco na variável de interesse
  select(!location:viewport) |>
  unnest_wider(bounds)
```

Então renomeamos `southwest` e `northeast` (os cantos do retângulo) para podermos usar `names_sep` para criar nomes curtos porém com algum significado:

```{r}
locations |> 
  select(city, formatted_address, geometry) |> 
  unnest_wider(geometry) |> 
  select(!location:viewport) |>
  unnest_wider(bounds) |> 
  rename(ne = northeast, sw = southwest) |> 
  unnest_wider(c(ne, sw), names_sep = "_") 
```

Veja como desaninhamos duas colunas simultaneamente fornecendo um vetor com os nomes das variáveis para `unnest_wider()`.

Uma vez que você descobriu o caminho para os elementos de interesse, você pode extraí-los diretamente usando outra função tidyr, `hoist()`:

```{r}
#| results: false
locations |> 
  select(city, formatted_address, geometry) |> 
  hoist(
    geometry,
    ne_lat = c("bounds", "northeast", "lat"),
    sw_lat = c("bounds", "southwest", "lat"),
    ne_lng = c("bounds", "northeast", "lng"),
    sw_lng = c("bounds", "southwest", "lng"),
  )
```

Se esses estudos de caso aguçaram seu apetite para mais representações retangulares na vida real, você pode ver alguns outros exemplos na `vignette("rectangling", package = "tidyr")`.

### Exercícios

1.  Estime aproximadamente quando o `gh_repos` foi criado.
    Porque você só pode estimar aproximadamente esta data?

2.  A coluna `owner` do `gh_repo` contém muitas informações duplicadas pois cada pessoa proprietária pode ter vários repositórios.
    Você consegue contruir um *data frame* `owners` que contém uma linha para cada pessoa proprietária?
    (Dica: A `distinct()` funciona com `list-cols`?)

3.  Siga os passos usados em `titles` para criar tabelas similares para *aliases*, *allegiances*, *books* e *TV Series* para os personagens de *Game of Thrones*.

4.  Explique o seguinte código linha a linha.
    Por que este código é interessante?
    Por que ele funciona para `got_chars` mas pode não funcionar em geral?

    ```{r}
    #| results: false
    tibble(json = got_chars) |> 
      unnest_wider(json) |> 
      select(id, where(is.list)) |> 
      pivot_longer(
        where(is.list), 
        names_to = "name", 
        values_to = "value"
      ) |>  
      unnest_longer(value)
    ```

5.  No `gmaps_cities`, o que `address_components` contém?
    Por que o tamanho varia entre as linhas?
    Desaninhe-o devidamente para entender.
    (Dica: `types` parece ter sempre dois elementos. O `unnest_wider()` funcionaria mais fácil que o `unnest_longer()`?)
    .

## JSON

Todos os estudos de caso na seção anterior foram originados de JSONs bruto/proveniente de fontes diretas.
JSON é abreviação de **j***ava***s***cript* **o***bject* **n***otation* e é a forma que a maioria das APIs da web retornam dados.
É importante saber que apesar dos tipos de dados JSON e R serem muito similares, não há uma correspondência de mapeamento 1-para-1, portanto é bom entender um pouco sobre JSON caso algo dê errado.

### Tipos de dados

JSON é um formato simples projetado para ser lido e escrito por máquinas, não humanos.
Ele tem seis tipos de dados chaves.
Quatro deles são escalares:

-   O tipo mais simples é o nulo (`null`) que tem o mesmo papel do `NA` no R. Representa ausência de dados.
-   **string** é muito parecido com *string* no R, porém deve ter sempre aspas duplas.
-   **number** é similar o *number* do R: podem ser inteiro (e.x., 123), decimal (e.x., 123.45), or notação científica (e.x., 1.23e3). JSON não suporta `Inf`, `-Inf`, ou `NaN`.
-   **boolean** é similar a `TRUE` e `FALSE` do R, mas usa letras minúsculas `true` e `false`.

*Strings*, números e booleanos do JSON são muito similares aos vetores de caracteres, numéricos e lógicos do R.
A principal diferença é que os escalares do JSON podem representar apenas um único valor.
Para representar valores múltiplos você precisa usar algum dos outros dois tipos: *arrays* e *objects*.

Tanto *arrays* quanto *objects* são similares às listas no R; a diferença é se são nomeados ou não nomeados.
Um **array** é como uma lista não nomeada e é escrito com `[]`.
Por exemplo, `[1, 2, 3]` é um *array* contendo 3 números e `[null, 1, "string", false]` é um *array* que contém um nulo, um número, uma *string* e um booleano.
Um **object** é como uma lista nomeada e é escrito com `{}`.
Os nomes (chaves na terminologia JSON) são *strings*, portanto devem ter aspas.
Por exemplo, `{"x": 1, "y": 2}` é um objeto que mapeia 1 para `x` e 2 para `y`.

Note que JSON não possui um jeito nativo para representar datas e data_hora (*datetime*), então estes são geralmente armazenados como *strings* e você deverá usar `readr::parse_date()` ou `readr::parse_datetime()` para transformá-los na estrutura de dados correta.
Da mesma forma, a regras do JSON para representar número com ponto flutuante (*floating points*), são um pouco imprecisas, portanto você também encontrará algumas vezes números armazenados como *strings*.
Aplique `readr::parse_double()` conforme necessário para obter os tipo correto.

### jsonlite

Para converter JSON em estruturas de dados do R, recomendamos o pacote jsonlite, de Jeroen Ooms.
Usaremos apenas duas funções do jsonlite: `read_json()` e `parse_json()`.
Na vida real, você usará `read_json()` para importar arquivos JSON do disco.
Por exemplo, o pacote repurrsive também é a fonte do `gh_user` como um arquivo JSON e você pode importá-la com `read_json()`:

```{r}
# Um caminho para o arquivo JSON dentro do pacote:
gh_users_json()

# Importe com read_json()
gh_users2 <- read_json(gh_users_json())

# Verifique se é o mesmo dado que usamos anteriormente
identical(gh_users, gh_users2)
```

Neste livro, usaremos também `parse_json()`, que recebe uma *string* representando um JSON, o que a torna boa para gerar exemplos simples.
Para começar, aqui estão três simples conjuntos de dados JSON, começando com um número, e então adicionando alguns números em *array* e em seguida adicionando esse *array* em um *object*:

```{r}
str(parse_json('1'))
str(parse_json('[1, 2, 3]'))
str(parse_json('{"x": [1, 2, 3]}'))
```

jsonlite tem uma outra função importante chamada `fromJSON()`.
Não a usamos aqui, pois efetua uma simplificação automática (`simplifyVector = TRUE`).
Isto geralmente funciona bem, particularmente em casos simples, mas achamos que é mais vantajoso se fizer você mesmo a representação retangular para que saiba exatamente o que está acontecendo e possa lidar mais facilmente com estruturas aninhadas mais complexas.

### Iniciando o processo de representação retangular

Na maioria dos casos, arquivos JSON contém um único *array* de nível mais alto (*top-level*), pois são projetados para prover dados sobre várias "coisas", e.x. várias páginas, ou vários registros, ou vários resultados.
Neste caso, você comecará sua representação retangular com `tibble(json)` para que cada elemento se torne uma linha:

```{r}
json <- '[
  {"nome": "John", "idade": 34},
  {"nome": "Susan", "idade": 27}
]'
df <- tibble(json = parse_json(json))
df

df |> 
  unnest_wider(json)
```

Em alguns casos raros, arquivos JSON são constituídos por um único *object* no nível mais alto, representando uma "coisa".
Neste caso, você precisará iniciar o processo de representação retangular colocando-o em uma lista antes de colocá-lo em um *tibble*.

```{r}
json <- '{
  "status": "OK", 
  "results": [
    {"nome": "John", "idade": 34},
    {"nome": "Susan", "idade": 27}
 ]
}
'
df <- tibble(json = list(parse_json(json)))
df

df |> 
  unnest_wider(json) |> 
  unnest_longer(results) |> 
  unnest_wider(results)
```

Alternativamente, você pode acessar o JSON analisado e começar com a parte que realmente lhe interessa:

```{r}
df <- tibble(results = parse_json(json)$results)
df |> 
  unnest_wider(results)
```

### Exercícios

1.  Represente retangularmente o `df_col` e `df_linha` abaixo.
    Eles representam duas formas de codificar um *data frame* em JSON.

    ```{r}
    json_col <- parse_json('
      {
        "x": ["a", "x", "z"],
        "y": [10, null, 3]
      }
    ')
    json_linha <- parse_json('
      [
        {"x": "a", "y": 10},
        {"x": "x", "y": null},
        {"x": "z", "y": 3}
      ]
    ')

    df_col <- tibble(json = list(json_col)) 
    df_linha <- tibble(json = json_linha)
    ```

## Resumo

Neste capítulo, você aprendeu o que são listas, como você pode gerá-las a partir de arquivos JSON e como transformá-las em *data frames* retangulares.
Surpreendentemente, precisamos de apenas duas funções: `unnest_longer()` para colocar elementos da lista em linhas e `unnest_wider()` para colocar os elementos da lista em colunas.
Não importa quão profundamente aninhada esteja a *list-column*; tudo que você precisa fazer é chamar repetidamente essas duas funções.

JSON é o formato de dados mais comum retornados por APIs web.
E se o *website* não possuir uma API, mas você puder ver os dados desejados no *website*?
Este é o tópico do próximo capítulo: Raspagem de dados (*web scraping*), extraindo dados de páginas web HTML.