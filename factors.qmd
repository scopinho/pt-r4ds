# Fatores {#sec-factors}

```{r}
#| echo: false
#| results: asis

source("_common.R")

```

## Introdução

Fatores (*factors*) são usados para variáveis categóricas, variáveis que possuem um conjunto fixo e conhecido de valores possíveis.
Eles também são úteis quando você deseja exibir vetores de caracteres em ordem não alfabética.

Começaremos motivando a necessidade de fatores para a análise de dados[^factors-1] e como você pode criá-los com a função `factor()`. Em seguida, apresentaremos o conjunto de dados `questionario` do pacote dados, que contém um monte de variáveis categóricas para experimentarmos.
Em seguida, você usará esse conjunto de dados para praticar a modificação da ordem e dos valores dos fatores, antes de terminarmos com uma discussão sobre fatores ordenados.

[^factors-1]: Eles também são muito importantes para modelagem.

### Pré-requisitos

O R base fornece algumas ferramentas básicas para criar e manipular fatores.
Iremos complementá-las com o pacote **forcats**, que é um integrante do tidyverse.
Ele fornece ferramentas para lidar com variáveis **cat**egóricas (e é um anagrama de fatores!) usando uma ampla gama de funções auxiliares para trabalhar com fatores.

```{r}
#| label: setup
#| message: false

library(tidyverse)
library(dados)
```

## O básico sobre fatores

Imagine que você tem uma variável que registra o mês:

```{r}
x1 <- c("Dez", "Abr", "Jan", "Mar")
```

Usar uma *string* para registrar esta variável tem dois problemas:

1.  Existem apenas doze meses possíveis e não há nada que proteja você contra erros de digitação:

    ```{r}
    x2 <- c("Dez", "Abr", "Jam", "Mar")
    ```

2.  Não ordena de maneira útil:

    ```{r}
    sort(x1)
    ```

Você pode corrigir esses dois problemas com um fator.
Para criar um fator você deve começar criando uma lista com **níveis** (*levels*) válidos:

```{r}
niveis_meses <- c(
  "Jan", "Fev", "Mar", "Abr", "Mai", "Jun", 
  "Jul", "Ago", "Set", "Out", "Nov", "Dez"
)
```

Agora você pode criar o fator:

```{r}
y1 <- factor(x1, levels = niveis_meses)
y1

sort(y1)
```

E quaisquer valores que não estejam nos níveis serão convertidos silenciosamente para NA:

```{r}
y2 <- factor(x2, levels = niveis_meses)
y2
```

Isso parece arriscado, então você pode querer usar `forcats::fct()` em vez disso:

```{r}
#| error: true
y2 <- fct(x2, levels = niveis_meses)
```

Se você omitir os níveis, eles serão retirados dos dados em ordem alfabética:

```{r}
factor(x1)
```

Classificar em ordem alfabética é um pouco arriscado porque nem todo computador classificará as *strings* da mesma maneira.
Então `forcats::fct()` ordena pela primeira aparição:

```{r}
fct(x1)
```

Se você precisar acessar diretamente o conjunto de níveis válidos, poderá fazê-lo com `levels()`:

```{r}
levels(y2)
```

Você também pode criar um fator ao ler seus dados com readr usando a `col_factor()`:

```{r}
csv <- "
mes,valor
Jan,12
Fev,56
Mar,12"

df <- read_csv(csv, col_types = cols(mes = col_factor(niveis_meses)))
df$mes
```

## Questionário

No restante deste capítulo, usaremos `dados::questionario`.
É uma amostra de dados da [Pesquisa Social Geral](https://gss.norc.org), uma pesquisa de longa data nos EUA conduzida pela organização de pesquisa independente NORC da Universidade de Chicago.
A pesquisa tem milhares de perguntas, então em `questionario`, Hadley selecionou algumas que ilustrarão alguns desafios comuns que você encontrará ao trabalhar com fatores.

```{r}
questionario
```

(Lembre-se, como este conjunto de dados é fornecido por um pacote, você pode obter mais informações sobre as variáveis com `?questionario`.)

Quando os fatores são armazenados em um *tibble*, você não consegue ver seus níveis tão facilmente.
Uma maneira de visualizá-los é com `count()`:

```{r}
questionario |>
  count(raca)
```

Ao trabalhar com fatores, as duas operações mais comuns são alterar a ordem dos níveis e alterar os valores dos níveis.
Essas operações são descritas nas seções abaixo.

### Exercícios

1.  Explore a distribuição de `renda` (renda informada).
    O que torna o gráfico de barras padrão difícil de ser entendido?
    Como você pode melhorar o gráfico?

2.  Qual a `religiao` mais comum neste questionário?
    Qual o `partido` mais comum?

3.  Qual `denominacao` se aplica a qual `religiao`?
    Como você pode descobrir isso com uma tabela?
    Como você pode descobrir isso com uma visualização?

## Modificando a ordem de um fator {#sec-modifying-factor-order}

Muitas vezes é útil alterar a ordem dos níveis dos fatores em uma visualização.
Por exemplo, imagine que você deseja explorar o número médio de horas gastas assistindo TV por dia em todas as religiões:

```{r}
#| fig-alt: |
#|   Um gráfico de dispersão com horas_tv no eixo-x e religião no eixo-y.
#|   O eixo-y parece estar ordenado de forma arbitrária, tornando difícil entender
#|   qualquer padrão geral.
resumo_religiao <- questionario |>
  group_by(religiao) |>
  summarize(
    horas_tv = mean(horas_tv, na.rm = TRUE),
    n = n()
  )

ggplot(resumo_religiao, aes(x = horas_tv, y = religiao)) + 
  geom_point()
```

É difícil ler esse gráfico porque não existe um padrão geral.
Podemos melhorá-lo reordenando os níveis de `religiao` usando `fct_reorder()`.
`fct_reorder()` possui três argumentos:

-   `f`, o fator cujos níveis você deseja modificar.
-   `x`, um vetor numérico que você deseja usar para reordenar os níveis.
-   Opcionalmente, `fun`, uma função que é usada se houver vários valores de `x` para cada valor de `f`. A função padrão é `median`.

```{r}
#| fig-alt: |
#|   O mesmo gráfico de dispersão acima, mas agora a religião é exibida em
#|   ordem crescente de horas_tv. "Outra religião oriental Leste" tem o menor número de horas de TV,
#|   menos de 2, e “Não sabe” tem o valor mais alto (acima de 5).
ggplot(resumo_religiao, aes(x = horas_tv, y = fct_reorder(religiao, horas_tv))) +
  geom_point()
```

Reordenar a religião torna muito mais fácil ver que as pessoas na categoria “Não sabe” assistem muito mais TV, e o Hinduísmo e outras religiões orientais assistem muito menos.

À medida que você começa a fazer transformações mais complicadas, recomendamos movê-las de `aes()` para uma etapa separada, usando `mutate()`.
Por exemplo, você poderia reescrever o gráfico acima como:

```{r}
#| eval: false

resumo_religiao |>
  mutate(
    religiao = fct_reorder(religiao, horas_tv)
  ) |>
  ggplot(aes(x = horas_tv, y = religiao)) +
  geom_point()
```

E se criarmos um gráfico semelhante observando como a idade média varia de acordo com o nível de renda informada?

```{r}
#| fig-alt: |
#|   Um gráfico de dispersão com idade no eixo-x e renda no eixo-y. A renda
#|   foi reordenada com base na idade média, o que não faz muito
#|   sentido. Uma seção do eixo-y vai de US$6.000 a 6.999, depois < US$ 1.000, 
#|   então $8000-9999.
resumo_renda <- questionario |>
  group_by(renda) |>
  summarize(
    idade = mean(idade, na.rm = TRUE),
    n = n()
  )

ggplot(resumo_renda, aes(x = idade, y = fct_reorder(renda, idade))) + 
  geom_point()
```

Aqui, reordenar arbitrariamente os níveis não é uma boa ideia!
Isso porque `renda` já tem uma ordem fundamentada com a qual não devemos mexer.
Reserve `fct_reorder()` para fatores cujos níveis são ordenados arbitrariamente.

No entanto, faz sentido colocar "Não se aplica" na frente com os outros níveis especiais.
Você pode usar `fct_relevel()`.
É necessário um fator, `f`, e então qualquer número de níveis que você deseja mover para o início da linha.

```{r}
#| fig-alt: |
#|   O mesmo gráfico de dispersão, mas agora "Não se aplica", é exibido na
#|   parte inferior do eixo-y. Geralmente há uma associação positiva
#|   entre renda e idade, e a faixa de renda com maior média
#|   idade é "Não se aplica".

ggplot(resumo_renda, aes(x = idade, y = fct_relevel(renda, "Não se aplica"))) +
  geom_point()
```

Por que você acha que a idade média para “Não se aplica” é tão alta?

Outro tipo de reordenação é útil quando você está colorindo as linhas em um gráfico.
`fct_reorder2(f, x, y)` reordena o fator `f` pelos valores `y` associados aos maiores valores `x`.
Isso torna o gráfico mais fácil de ler porque as cores da linha na extremidade direita do gráfico se alinharão com a legenda.

```{r}
#| layout-ncol: 2
#| fig-width: 3
#| fig-alt: |
#|     Um gráfico de linha com idade no eixo-x e proporção no eixo-y.
#|     Há uma linha para cada categoria de estado civil: sem resposta,
#|     nunca casou, separado(a), divorciado(a), viúvo(a) e casado(a). O gráfico é
#|     um pouco difícil de ler porque a ordem da legenda não é 
#|     relacionada às linhas do gráfico. Reorganizar a legenda faz 
#|     o gráfico ser mais fácil de ser lido porque as cores da legenda agora correspondem à 
#|     ordem das linhas na extremidade direita do gráfico. Você pode ver alguns 
#|     padrões não surpreendentes: a proporção de nunca casados(as) ​​diminui com a
#|     idade, casado(a) forma um U de cabeça para baixo e viúvo(a) começa
#|     baixo, mas aumenta acentuadamente após os 60 anos.
por_idade <- questionario |>
  filter(!is.na(idade)) |> 
  count(idade, estado_civil) |>
  group_by(idade) |>
  mutate(
    prop = n / sum(n)
  )

ggplot(por_idade, aes(x = idade, y = prop, color = estado_civil)) +
  geom_line(linewidth = 1) + 
  scale_color_brewer(palette = "Set1")

ggplot(por_idade, aes(x = idade, y = prop, color = fct_reorder2(estado_civil, idade, prop))) +
  geom_line(linewidth = 1) +
  scale_color_brewer(palette = "Set1") + 
  labs(color = "estado civil") 
```

Finalmente, para gráficos de barras, você pode usar `fct_infreq()` para ordenar os níveis em frequência decrescente: este é o tipo mais simples de reordenação porque não precisa de nenhuma variável extra..
Combine-a com a `fct_rev()` se desejar que eles aumentem a frequência, de modo que no gráfico de barras os maiores valores fiquem à direita, não à esquerda.

```{r}
#| fig-alt: |
#|   Um gráfico de barras de estado civil ordenado do menos para mais comum:
#|   sem resposta (~0), separado(a) (~1,000), viúvo(a) (~2,000), divorciado(a) 
#|   (~3,000), nuca casou (~5,000), casado(a) (~10,000).
questionario |>
  mutate(estado_civil = estado_civil |> fct_infreq() |> fct_rev()) |>
  ggplot(aes(x = estado_civil)) +
  geom_bar()
```

### Exercícios

1.  Existem alguns números suspeitosamente altos em `horas_tv`.
    A média é um bom resumo?

2.  Para cada fator em `questionario`, identifique se a ordem dos níveis é arbitrária ou fundamentada.

3.  Por que mover "Não se aplica" para a frente dos níveis o moveu para a parte inferior do gráfico?

## Modificando os níveis do fator

Mais poderoso do que alterar as ordens dos níveis é alterar os seus valores.
Isso permite esclarecer rótulos para publicação e recolher níveis para exibições de alto nível.
A ferramenta mais geral e poderosa é `fct_recode()`.
Ela permite recodificar, ou alterar, o valor de cada nível.
Por exemplo, pegue a variável `partido` do *data frame* `questionario`:

```{r}
questionario |> count(partido)
```

Os níveis são concisos e inconsistentes.
Vamos ajustá-los para serem mais longos e usar uma construção paralela.
Como a maioria das funções de renomeação e recodificação no tidyverse, os novos valores ficam à esquerda e os valores antigos à direita:

```{r}
questionario |>
  mutate(
    partido = fct_recode(partido,
      "Indivíduo fortemente republicano"    = "Fortemente republicano",
      "Indivíduo não fortemente republicano"      = "Não fortemente republicano",
      "Indivíduo independente com inclinação republicana" = "Independente, inclinação republicana",
      "Indivíduo independente com inclinação democrata" = "Independente, inclinação democrata",
      "Indivíduo não fortemente democrata"        = "Não fortemente democrata",
      "Indivíduo fortemente democrata"      = "Fortemente democrata"
    )
  ) |>
  count(partido)
```

`fct_recode()` deixará os níveis que não são explicitamente mencionados como estão e irá avisá-lo se você acidentalmente se referir a um nível que não existe.

Para combinar grupos, você pode atribuir vários níveis antigos a um mesmo nível novo:

```{r}
#| results: false
questionario |>
  mutate(
    partido = fct_recode(partido,
      "Indivíduo fortemente republicano"    = "Fortemente republicano",
      "Indivíduo não fortemente republicano"      = "Não fortemente republicano",
      "Indivíduo independente com inclinação republicana" = "Independente, inclinação republicana",
      "Indivíduo independente com inclinação democrata" = "Independente, inclinação democrata",
      "Indivíduo não fortemente democrata"        = "Não fortemente democrata",
      "Indivíduo fortemente democrata"      = "Fortemente democrata",
      "Outro"                 = "Sem resposta",
      "Outro"                 = "Não sabe",
      "Outro"                 = "Outro partido"
    )
  )
```

Use esta técnica com cuidado: se você agrupar categorias que são realmente diferentes, você acabará com resultados enganosos.

Se você deseja recolher vários níveis, `fct_collapse()` é uma variante útil de `fct_recode()`.
Para cada nova variável, você pode fornecer um vetor de níveis antigos:

```{r}
questionario |>
  mutate(
    partido = fct_collapse(partido,
      "other" = c("Sem resposta", "Não sabe", "Outro partido"),
      "rep" = c("Fortemente republicano", "Não fortemente republicano"),
      "ind" = c("Independente, inclinação republicana", "Independente", "Independente, inclinação democrata"),
      "dem" = c("Não fortemente democrata", "Fortemente democrata")
    )
  ) |>
  count(partido)
```

Às vezes, você só quer juntar em pequenos grupos para simplificar um gráfico ou uma tabela.
Esse é o trabalho da família de funções `fct_lump_*()`.
`fct_lump_lowfreq()` é um ponto de partida simples que agrupa progressivamente as categorias dos menores grupos em "Outros", sempre mantendo "Outros" como a menor categoria.

```{r}
questionario |>
  mutate(religiao = fct_lump_lowfreq(religiao)) |>
  count(religiao)
```

Neste caso, não ajuda muito: é verdade que a maioria dos americanos nesta pesquisa são protestantes, mas provavelmente gostaríamos de ver mais alguns detalhes!
Em vez disso, podemos usar `fct_lump_n()` para especificar que queremos exatamente 10 grupos:

```{r}
questionario |>
  mutate(religiao = fct_lump_n(religiao, n = 10)) |>
  count(religiao, sort = TRUE)
```

Leia a documentação para aprender sobre `fct_lump_min()` e `fct_lump_prop()` que são úteis em outros casos.

### Exercícios

1.  Como mudaram ao longo do tempo as proporções de pessoas que se identificam como Democratas, Republicanas e Independentes?

2.  Como você poderia agrupar a “renda” em um pequeno conjunto de categorias?

3.  Observe que existem 9 grupos (excluindo outros) no exemplo `fct_lump` acima.
    Por que não 10?
    (Dica: digite `?fct_lump` e note que o padrão para o argumento `other_level` é "Other".)

## Fatores ordenados {#sec-ordered-factors}

Antes de prosseguirmos, há um tipo especial de fator que precisa ser mencionado brevemente: fatores ordenados.
Fatores ordenados, criados com `ordered()`, implicam uma ordenação estrita e distância igual entre os níveis: o primeiro nível é "menor que" o segundo nível na mesma quantidade que o segundo nível é "menor que" o terceiro nível e assim por diante.
Você pode reconhecê-los ao imprimir porque eles usam `<` entre os níveis dos fatores:

```{r}
ordered(c("a", "b", "c"))
```

Na prática, os fatores ordenados (`ordered()`) se comportam de forma muito semelhante aos fatores regulares.
Existem apenas dois lugares onde você pode notar um comportamento diferente:

-   Se você mapear um fator ordenado para colorir ou preencher no ggplot2, o padrão será `scale_color_viridis()`/`scale_fill_viridis()`, uma escala de cores que implica um ranqueamento.
-   Se você usar uma função ordenada em um modelo linear, ela usará "contrastes poligonais". Eles são moderadamente úteis, mas é improvável que você já tenha ouvido falar deles, a menos que tenha um PhD em Estatística e, mesmo assim, provavelmente não os interpreta rotineiramente. Se você quiser saber mais, recomendamos a `vignette("contrasts", package = "faux")` de Lisa DeBruine.

Dada a utilidade discutível dessas diferenças, geralmente não recomendamos o uso de fatores ordenados.

## Resumo

Este capítulo apresentou o prático pacote forcats para trabalhar com fatores, apresentando as funções mais comumente usadas.
O pacote forcats contém uma ampla gama de outras funções auxiliares que não tivemos espaço para discutir aqui, portanto, sempre que você estiver enfrentando um desafio de análise com fatores que não encontrou antes, recomendo fortemente dar uma olhada no [índice remissivo](https://forcats.tidyverse.org/reference/index.html) para ver se existe uma função pronta que pode ajudar a resolver seu problema.

Se você quiser aprender mais sobre fatores depois de ler este capítulo, recomendamos a leitura do artigo de Amelia McNamara e Nicholas Horton, [*Wrangling categorical data in R*](https://peerj.com/preprints/3163/).
Este artigo apresenta um pouco da história discutida em [*stringsAsFactors: Uma biografia não autorizada*](https://simplystatistics.org/posts/2015-07-24-stringsasfactors-an-unauthorized-biography/) e [*stringsAsFactors = \<sigh\>*](https://notstatschat.tumblr.com/post/124987394001/stringsasfactors-sigh) e compara as abordagens organizadas (*tidy approach*) para dados categóricos descritos neste livro com métodos do R base.
Uma versão inicial do documento ajudou a motivar e definir o escopo do pacote forcats; obrigado Amélia e Nick!

No próximo capítulo, mudaremos de assunto para começar a aprender sobre datas e horários no R.
Datas e horários parecem enganosamente simples, mas como você verá em breve, quanto mais você aprende sobre eles, mais complexos eles parecem se tornar!
