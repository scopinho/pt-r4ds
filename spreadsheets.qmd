# ✅ Planilhas {#sec-import-spreadsheets}

```{r}
#| echo: false
#| results: asis

source("_common.R")
```

## Introdução

No @sec-data-import você aprendeu sobre importação de dados de arquivos de texto como `.csv` e `.tsv`.
Agora chegou a hora de aprender a extrair dados de planilhas, tanto do Excel quanto do Planilhas Google (*Google Sheets*).
Para isto, usaremos muito do que você aprendeu no @sec-data-import, mas discutiremos também considerações adicionais e complexidades presentes quando trabalhamos com dados vindos de planilhas.

Se você ou seus colaboradores estão usando planilhas para organizar dados, nós recomendamos fortemente a leitura do artigo "Organização de Dados em Planilhas (*Data Organization in Spreadsheets*) de Karl Broman e Kara Woo: <https://doi.org/10.1080/00031305.2017.1375989>. As boas práticas presentes neste artigo evitarão dores de cabeça ao importar dados de planilhas para análise e visualização com o R.

## Excel

O Microsoft Excel é um software muito utilizado onde os dados são organizados em planilhas (*worksheets*) dentro de arquivos Excel (*spreadsheet*).

### Pré-requisitos

Nesta seção, você aprenderá como carregar dados de arquivos do Excel para o R com o pacote **readxl**.
Este pacote faz parte dos componentes secundários (*non-core*) do tidyverse, portanto devemos carregá-lo explicitamente, apesar dele já ser instalado automaticamente quando você instala o tidyverse.
Posteriormente, usaremos também o pacote writexl, que nos permite criar planilhas do Excel.

```{r}
#| message: false

library(readxl)
library(tidyverse)
library(writexl)
```

### Iniciando

Muitas funções do readxl te permitem importar arquivos do Excel para o R:

-   `read_xls()` importa arquivos Excel que estejam no formato `xls`.
-   `read_xlsx()` importa arquivos Excel que estejam no formato `xlsx`.
-   `read_excel()` pode importar arquivos em ambos os formatos `xls` e `xlsx`. Ela identifica o formato baseado no tipo de arquivo de entrada.

Estas funções possuem uma sintaxe similar às outras funções introduzidas anteriormente para importar outros tipos de arquivos, por exemplo: `read_csv()`, `read_table()`, etc.
No restante deste capítulo focaremos no uso da função `read_excel()`.

### Importando arquivos do Excel {#sec-reading-spreadsheets-excel}

A @fig-students-excel mostra como é a planilha do Excel que iremos importar para o R.
Esta planilha pode ser baixada em <https://github.com/cienciadedatos/pt-r4ds/raw/traducao-pt-2ed/data/estudantes.xlsx>.

```{r}
#| label: fig-students-excel
#| echo: false
#| fig-width: 5
#| fig-cap: |
#|   Planilha do Excel chamada estudantes.xlsx.
#| fig-alt: |
#|   Uma visão da planilha de estudantes no Excel. A planilha possui 
#|   informações de 6 estudantes, seus IDs, nomes completos, comida favorita, plano alimentar
#|   e idade.

knitr::include_graphics("screenshots/import-spreadsheets-students.png")
```

O primeiro argumento da `read_excel()` é o caminho (*path*) do arquivo a ser importado.

```{r}
estudantes <- read_excel("data/estudantes.xlsx")
```

`read_excel()` irá importar o arquivo como um *tibble*.

```{r}
estudantes
```

Temos seis estudantes nos dados e cinco variáveis para cada estudante.
Entretanto, existem algumas coisas que devemos abordar neste conjunto de dados:

1.  Os nomes das colunas estão com formato inconsistente.
    Você pode fornecer nomes que seguem um formato consistente; nós recomendamos o `snake_case` usando o argumento `col_names`.

    ```{r}
    #| include: false

    options(
      dplyr.print_min = 7,
      dplyr.print_max = 7
    )
    ```

    ```{r}
    read_excel(
      "data/estudantes.xlsx",
      col_names = c("estudante_id", "nome_completo", "comida_favorita", "refeicao_plano", "idade")
    )
    ```

    ```{r}
    #| include: false

    options(
      dplyr.print_min = 6,
      dplyr.print_max = 6
    )
    ```

    Infelizmente, apenas isto não é o suficiente.
    Temos agora o nome das variáveis como gostaríamos, mas o que era anteriormente a linha de cabeçalho passou a aparecer nos dados como a primeira linha das observações.
    Você pode pular explicitamente esta linha usando o argumento `skip`.

    ```{r}
    read_excel(
      "data/estudantes.xlsx",
      col_names = c("estudante_id", "nome_completo", "comida_favorita", "refeicao_plano", "idade"),
      skip = 1
    )
    ```

2.  Na coluna `comida_favorita`, uma das observações está como `N/A`, que significa "não disponível" (*not available*) mas essa forma não é reconhecida como um valor não disponível (`NA`) do R (veja a diferença entre este `N/A` e o presente na `idade` do quarto estudante da lista).
    Você pode definir quais cadeias de caracteres (*strings*) devem ser reconhecidas pelo R como `NA` utilizando o argumento `na`.
    Por padrão, apenas `""` (*string* vazia, ou, quando trabalhando com uma planilha, uma célula vazia ou com a fórmula `=NA()`) é reconhecida como um `NA`.

    ```{r}
    read_excel(
      "data/estudantes.xlsx",
      col_names = c("estudante_id", "nome_completo", "comida_favorita", "refeicao_plano", "idade"),
      skip = 1,
      na = c("", "N/A")
    )
    ```

3.  Um outro ponto que devemos observar é que a coluna `idade` é importada como uma variável texto, quando, na realidade, deveria ser numérica.
    Assim como na `read_csv()` e outras funções que importam dados de arquivos texto, você pode passar o argumento `col_types` para a `read_excel()` e especificar os tipos das colunas das variáveis que você está importanto.
    Porém, a sintaxe é um pouco diferente.
    Suas opções são: `"skip"`, `"guess"`, `"logical"`, `"numeric"`, `"date"`, `"text"` ou `"list"`.

    ```{r}
    read_excel(
      "data/estudantes.xlsx",
      col_names = c("estudante_id", "nome_completo", "comida_favorita", "refeicao_plano", "idade"),
      skip = 1,
      na = c("", "N/A"),
      col_types = c("numeric", "text", "text", "text", "numeric")
    )
    ```

    Porém, apenas isso também não produz o resultado desejado.
    Definindo que `idade` deve ser numérica, nós transformamos a célula com um valor não-numérico (aquela com valor `cinco`) em um `NA`.
    Neste caso, você deve importar `idade` como `"text"` e então fazer a mundança após os dados estarem carregados no R.

    ```{r}
    estudantes <- read_excel(
      "data/estudantes.xlsx",
      col_names = c("estudante_id", "nome_completo", "comida_favorita", "refeicao_plano", "idade"),
      skip = 1,
      na = c("", "N/A"),
      col_types = c("numeric", "text", "text", "text", "text")
    )

    estudantes <- estudantes |>
      mutate(
        idade = if_else(idade == "cinco", "5", idade),
        idade = parse_number(idade)
      )

    estudantes
    ```

Foram necessários vários passos com tentativas e erros para importar os dados da maneira que precisávamos, e isto não é algo inesperado.
A ciência de dados é um processo iterativo, e este processo de iteração pode ser ainda mais entediante quando importamos dados de planilhas se comparado a quando importamos dados de arquivos textos (dados retangulares) pois os humanos tendem a inserir dados nas planilhas e usá-las não apenas para armazenar os dados, mas também para compartilhamento e communicação.

Não há como saber exatamente como os dados serão importados até você carregá-los e dar uma olhada.
Bem, na verdade há um jeito.
Você pode abrir o arquivo no Excel e dar uma olhada.
Se você for fazer isso, recomendamos fazer uma cópia do arquivo original e usar a outra cópia para navegar pelo arquivo, deixando a primeira inalterada para ser carregada pelo R.
Isto certificará que você não irá sobreescrever acidentalmente nada na planilha enquanto a inspeciona.
Você também não precisa ter medo de fazer o que fizemos aqui: Carregar o arquivo, dar uma olhada, fazer os ajustes no seu código, carregar novamente e repetir tudo até que esteja contente com o resultado.

### Importando planilhas

Uma característica importante que distingue arquivos do Excel de arquivos texto, é a noção de várias planilhas (ou abas) dentro do mesmo arquivo.
A @fig-penguins-islands mostra um arquivo Excel com várias planilhas.
Os dados são do pacote **palmerpenguins**, e você pode fazer o download como um arquivo Excel em <https://github.com/cienciadedatos/pt-r4ds/raw/traducao-pt-2ed/data/pinguins.xlsx>.
Cada planilha (ou aba) contém informações de pinguins de diferentes ilhas onde os dados foram coletados.

```{r}
#| label: fig-penguins-islands
#| echo: false
#| fig-cap: |
#|   Arquivo Excel chamado pinguins.xlsx contendo três planilhas (ou abas).
#| fig-alt: |
#|   Uma visão do arquivo de pinguins no Excel. O arquivo possui três planilhas: 
#|   Ilha Torgersen, Ilha Biscoe e Ilha Dream.

knitr::include_graphics("screenshots/import-spreadsheets-penguins-islands.png")
```

Você pode importar uma única planilha usando o argumento `sheet` na função `read_excel()`.
Por padrão, o que utilizamos até agora, a primeira planilha é importada.

```{r}
read_excel("data/pinguins.xlsx", sheet = "Ilha Torgersen")
```

Algumas variáveis que parecem conter dados numéricos, são importadas como caracteres (texto) devido à cadeia de caractere `"NA"` não ser reconhecida como um verdadeiro `NA`.

```{r}
pinguins_torgersen <- read_excel("data/pinguins.xlsx", sheet = "Ilha Torgersen", na = "NA")

pinguins_torgersen
```

Alternativamente, você pode usar `excel_sheets()` para obter informações de todas as planilhas presentes em um arquivo Excel, e então importar aquela(s) em que você está interessado.

```{r}
excel_sheets("data/pinguins.xlsx")
```

Assim que você souber o(s) nome(s) da(s) planilha(s), você pode importá-la(s) individualmente com `read_excel()`.

```{r}
pinguins_biscoe <- read_excel("data/pinguins.xlsx", sheet = "Ilha Biscoe", na = "NA")
pinguins_dream  <- read_excel("data/pinguins.xlsx", sheet = "Ilha Dream", na = "NA")
```

Neste caso, o conjunto de dados completo está espalhado entre três planilhas distintas no arquivo.
Cada planilha tem o mesmo número de colunas, mas diferentes números de linhas.

```{r}
dim(pinguins_torgersen)
dim(pinguins_biscoe)
dim(pinguins_dream)
```

Nós podemos uní-las usando `bind_rows()`.

```{r}
pinguins <- bind_rows(pinguins_torgersen, pinguins_biscoe, pinguins_dream)
pinguins
```

No @sec-iteration falaremos sobre outras maneiras de fazer este tipo de coisa sem repetir código.

### Importando parte de uma planilha

Uma vez que muitas pessoas usam arquivos do Excel tanto pra apresentação quanto para armazenamento dos dados, é muito comum encontrarmos células em uma planilha que não fazem parte dos dados que você quer importar para o R.
A @fig-deaths-excel mostra um exemplo: no centro da planilha temos algo que se parece com um *data frame*, mas existem estranhos textos acima e abaixo dos dados.

```{r}
#| label: fig-deaths-excel
#| echo: false
#| fig-cap: |
#|   Arquivo do Excel chamado deaths.xlsx
#| fig-alt: |
#|   Uma visão da planilha 'deaths' no Excel. A planilha possui quatro linhas 
#|   no topo contém informações extras aos dados; o texto 'Por razôes de  
#|   consistência no *layout* dos dados, algo que é realmente belo, continuarei 
#|   a fazer notas por aqui.' está espalhado pelas quatro linhas. 
#|   Então, há um *data frame* que inclui informações sobre os óbitos de 10  
#|   pessoas famosas, incluindo seus nomes, profissões, idades, se tinham filhos 
#|   ou não, data de nascimento e óbito. Na parte de baixo, existem outras 4 linhas 
#|   extras aos dados; no texto 'Isto tem sido realmente divertido, mas 
#|   estamos nos desconectando agora!' está espalhado por estas quatro linhas finais.

knitr::include_graphics("screenshots/import-spreadsheets-deaths.png")
```

Esta planilha é um dos exemplos fornecidos com o pacote readxl.
Você pode usar a função `readxl_example()` para localizar esta planilha no diretório em que o pacote foi instalado em seu computador.
Esta função retorna o caminho para o arquivo do Excel, que você pode importar usando a `read_excel()` como de costume.

```{r}
obitos_caminho <- readxl_example("deaths.xlsx")
obitos <- read_excel(obitos_caminho)
obitos
```

As primeiras três linhas e as quatro linhas no final, não fazem parte do *data frame*.
É possível eliminar estas linhas extras usando os argumentos `skip` e `n_max`, mas recomendamos utilizar intervalos (*range*) de células.
No Excel, a célula superior esquerda é a `A1`.
Conforme você se move pelas colunas para a direita, o título da célula segue a sequência do alfabeto, ou seja: `B1`, `C1`, etc.
E conforme você se move para baixo na coluna, o número da célula aumenta, ex: `A2`, `A3`, etc.

Aqui, os dados que desejamos importar começam na célula `A5` e terminam na célula `F15`.
Na notação da planilha, temos `A5:F15`, que fornecemos para o argumento `range`:

```{r}
read_excel(obitos_caminho, range = "A5:F15")
```

### Tipos de dados

Em arquivos CSV, todos os valores são *strings". Isto não é particularmente verdadeiro para os dados, mas é simples: tudo é uma* string".

Os dados intrínsecos nas planilhas Excel são mais complexos.
Uma célula pode conter uma dessas quatro coisas:

-   Um booleano, como `TRUE`, `FALSE`, ou `NA`.

-   Um número, como "10" ou "10.5".

-   Uma data/horário (*datetime*), que pode conter algo como "11/1/21" ou "11/1/21 3:00 PM".

-   Um texto (*string*), como "dez".

Quando trabalhamos com dados de planilhas, é importante ter em mente que os dados intrínsecos podem ser muito diferentes daquilo que vemos em uma célula.
Por exemplo, o Excel não tem a noção de 'inteiro' (*integer*).
Todos os números são armazenados como ponto flutuante (*floating points*), mas você pode optar em mostrar os dados de uma forma personalizada de casas decimais.
Da mesma maneira, datas são na verdade armazenadas como números, especificamente número de segundos desde 1º de Janeiro de 1970.
Você pode personalizar como você quer mostrar as datas no Excel aplicando formatações.
Para confundir ainda mais, também é possível ter algo que se parece com um número, mas é na verdade uma *string* (por exemplo: , digite `'10` em uma célula no Excel).

Estas diferenças em como os dados intrínsecos são armazenados vs. como eles são mostrados na tela podem causar surpresas quando os dados são importados para o R.
Por padrão, readxl tentará adivinhar o tipo de dado de uma determinada coluna.
Um fluxo de trabalho recomendado é deixar o readxl adivinhar os tipos das colunas, confirmar se você está contente com os tipos sugeridos, e caso não estiver, importar novamente especificando o argumento `col_types` como mostrado na @sec-reading-spreadsheets-excel.

Outro desafio é quando você tem uma coluna na planilha do Excel que tem uma mistura de diferentes tipos: algumas células são numéricas, outras contém texto, outras contém datas.
Quando importamos esses dados para o R, o readxl deve tomar algumas decisões.
Nestes casos, você pode definir o tipo para esta coluna como `"list"`, o qual importará a coluna como uma lista de vetores de tamanho 1, onde o tipo de cada elemento do vetor é sugerido.

::: callout-note
Algumas vezes os dados são armazenados de forma mais exótica, como cores de fundo da célula, ou com texto em negrito ou não.
Nestes casos, você pode achar útil o pacote [tidyxl](https://nacnudus.github.io/tidyxl/).
Veja <https://nacnudus.github.io/spreadsheet-munging-strategies/> para mais estratégias de trabalho com dados não tabulares vindos do Excel.
:::

### Exportando para Excel {#sec-writing-to-excel}

Vamos criar um pequeno conjunto de dados (*tibble*) que iremos exportar.
Note que `item` é um fator (*factor*) e `quantidade` é um inteiro (*integer*).

```{r}
doces_vendas <- tibble(
  item     = factor(c("brownie", "cupcake", "cookie")),
  quantidade = c(10, 5, 8)
)

doces_vendas
```

Você pode gravar estes dados em disco como um arquivo do Excel usando a função `write_xlsx()` do pacote [writexl package](https://docs.ropensci.org/writexl/):

```{r}
#| eval: false

write_xlsx(doces_vendas, path = "data/doces-vendas.xlsx")
```

A @fig-bake-sale-excel mostra como os dados aparecem no Excel.
Note que os nomes das colunas também aparecem em negrito.
Isto pode ser modificado definindo como `FALSE` os argumentos `col_names` e `format_headers`.

```{r}
#| label: fig-bake-sale-excel
#| echo: false
#| fig-width: 5
#| fig-cap: |
#|   Arquivo Excel chamado doces-vendas.xlsx.
#| fig-alt: |
#|   Conjunto de dados doces_vendas criado anteriormente mostrados no Excel.

knitr::include_graphics("screenshots/import-spreadsheets-bake-sale.png")
```

Assim como acontece quando importamos dados de um CSV, as informações sobre os tipos de dados são perdidas quando importamos os dados novamente.
Isto torna os arquivos do Excel uma fonte não confiável para armazenar resultados parciais.
Para alternativas, veja @sec-writing-to-a-file.

```{r}
read_excel("data/doces-vendas.xlsx")
```

### Saídas formatadas

O pacote writexl é uma solução simplificada para criar uma simples planilha do Excel, mas se você estiver interessado em características adicionais como escrever em uma planilha dentro de um arquivo e estilizá-la, você pode querer utilizar o pacote [openxlsx](https://ycphs.github.io/openxlsx).
Não entraremos nos detalhes deste pacote aqui, mas recomendamos ler <https://ycphs.github.io/openxlsx/articles/Formatting.html> para uma extensa discussão sobre outras funcionalidades de formatação de dados do R para o Excel usando o openxlsx.

Observe que este pacote não faz parte do tidyverse, portanto as funções e fluxos de trabalho podem não ser familiares.
Por exemplo, os nomes das funções usam *camelCase*, várias funções não podem compor um *pipeline*, e os argumentos tendem a seguir ordens diferentes daquelas do tidyverse.
Entretanto, tudo bem.
Conforme seu aprendizado e uso do R expandem para além deste livro, você encontrará vários outros estilos em diversos pacotes disponíveis para atingir seus objetivos específicos no R.
Uma boa forma de se familiarizar com o estilo de código em um novo pacote é executar alguns exemplos fornecidos na documentação das funções, sentir a sintaxe e formatos de saída, assim como ler qualquer *vignette* que acompanha o pacote.

### Exercícios

1.  Em um arquivo do Excel, crie o seguinte conjunto de dados e salve como `pesquisa.xlsx`.
    Alternativamente, você pode baixar [aqui](https://github.com/cienciadedatos/pt-r4ds/raw/traducao-pt-2ed/data/pesquisa.xlsx) como arquivo do Excel.

    ```{r}
    #| echo: false
    #| fig-width: 4
    #| fig-alt: |
    #|   Uma planilha com 2 colunas (pesquisa_id e n_animais_estimacao) e 7 linhas. 
    #|   A primeira linha possui os nomes das colunas. 
    #|   A coluna pesquisa_id possui números de 1 até 6.
    #|   A coluna n_animais_estimacao, possui valores entre 0 e 2, contendo dois valores em texto (N/A e two).

    knitr::include_graphics("screenshots/import-spreadsheets-survey.png")
    ```

    Depois, importe para o R tendo `pesquisa_id` como uma variável texto e `n_animais_estimacao` como uma variável numérica.

    ```{r}
    #| echo: false

    read_excel("data/pesquisa.xlsx", na = c("", "N/A"), col_types = c("text", "text")) |>
      mutate(
        n_animais_estimacao = case_when(
          n_animais_estimacao == "nenhum" ~ "0",
          n_animais_estimacao == "dois"  ~ "2",
          TRUE             ~ n_animais_estimacao
        ),
        n_animais_estimacao = as.numeric(n_animais_estimacao)
      )
    ```

2.  Em outro arquivo do Excel, crie o seguinte conjunto de dados e salve como `lista.xlsx`.
    Alternativamente, você pode baixar [aqui](https://github.com/cienciadedatos/pt-r4ds/raw/traducao-pt-2ed/data/lista.xlsx) como arquivo do Excel.

    ```{r}
    #| echo: false
    #| fig-width: 4
    #| fig-alt: |
    #|   Uma planilha com 3 colunas (grupo, subgrupo, e id) e 12 linhas. 
    #|   A coluna grupo contém dois valores: 1 (combinando 7 linhas juntas) e 2 
    #|   (combinando 5 linhas juntas). A coluna subgrupo tem quatro valores: A 
    #|   (combinando 3 linhas juntas), B (combinando 4 linhas juntas), A (combinando 2 
    #|   linhas juntas), e B (combinando 3 linhas juntas). A coluna id tem doze 
    #|   valores, números de 1 até 12.

    knitr::include_graphics("screenshots/import-spreadsheets-roster.png")
    ```

    Depois, importe-o para o R.
    O conjunto de dados resultante deve ser nomeado como `lista` e deve se parecer com o que é mostrado a seguir.

    ```{r}
    #| echo: false
    #| message: false

    read_excel("data/lista.xlsx") |>
      fill(grupo, subgrupo) |>
      print(n = 12)
    ```

3.  Em um novo arquivo do Excel, crie o seguinte conjunto de dados e salve como `vendas.xlsx`.
    Alternativamente, você pode baixar [aqui](https://github.com/cienciadedatos/pt-r4ds/raw/traducao-pt-2ed/data/vendas.xlsx) como arquivo do Excel.

    ```{r}
    #| echo: false
    #| fig-alt: |
    #|   Uma planilha com 2 colunas e 13 linhas. As primeiras duas linhas tem um texto 
    #|   contendo informações sobre a planilha. A linha 1 diz "Este arquivo contém informações
    #|   de vendas". A linha 2 diz "Dados estão organizados por nome da marca e 
    #|   para cada marca, temos um número ID para cada item vendido e quantos foram  
    #|   vendidos.". Depois existem duas linhas em branco seguidas por 9 linhas de dados.

    knitr::include_graphics("screenshots/import-spreadsheets-sales.png")
    ```

    a\.
    Importar `vendas.xlsx` e salvar como `vendas`.
    O conjunto de dados deve se parecer com o que é mostrado a seguir, com `id` e `n` como nomes das colunas e com 9 linhas.

    ```{r}
    #| echo: false
    #| message: false

    read_excel("data/vendas.xlsx", skip = 3, col_names = c("id", "n")) |>
      print(n = 9)
    ```

    b\.
    Modifique `vendas` de forma a ficar organizado (*tidy*) com três colunas (`marca`, `id`, e `n`) e 7 linhas de dados.
    Note que `id` e `n` são numéricas, `marca` é uma variável texto (ou caractere).

    ```{r}
    #| echo: false
    #| message: false

    read_excel("data/vendas.xlsx", skip = 3, col_names = c("id", "n")) |>
      mutate(marca = if_else(str_detect(id, "Marca"), id, NA)) |>
      fill(marca) |>
      filter(n != "n") |>
      relocate(marca) |>
      mutate(
        id = as.numeric(id),
        n = as.numeric(n)
      ) |>
      print(n = 7)
    ```

4.  Recrie o conjunto de dados `doces_vendas`, exporte para um arquivo do Excel usando a função `write.xlsx()` do pacote openxlsx.

5.  No @sec-data-import você aprendeu sobre a função `janitor::clean_names()` para transformar os nomes das colunas em *snake case*.
    Importe o arquivo `estudantes.xlsx` que foi introduzido anteriormente nesta seção e use a função para "limpar" os nomes das colunas.

6.  O que acontece se você tentar importar um arquivo com a extensão `.xlsx` com `read_xls()`?

## Planilhas Google (*Google Sheets*)

O Planilhas Google (*Google Sheets*) é um outro programa de planilha amplamente utilizado.
É gratuito e acessado via navegador (*web-based*).
Assim como o Excel, no Planilhas Google, os dados são armazenados em planilhas dentro de um arquivo.

### Pré-requisitos

Esta seção também será focada em planilhas, mas desta vez você irá carregar os dados do Planilhas Google com o pacote **googlesheets4**.
Este pacote também faz parte dos componentes secundários (*non-core*) do tidyverse, portanto devemos carregá-lo explicitamente.

```{r}
library(googlesheets4)
library(tidyverse)
```

Uma breve nota sobre o nome do pacote: googlesheets4 usa a versão 4 da [API do Planilhas Google](https://developers.google.com/sheets/api/) para fornecer uma interface do Planilhas Google para o R, por isso este nome.

### Iniciando

A principal função do pacote googlesheets4 é a `read_sheet()`, a qual importa uma planilha do Google a partir de uma URL ou id do arquivo.
Esta função também pode ser chamada pelo nome de `range_read()`.

Você também pode criar uma nova planilha com a `gs4_create()` ou escrever em uma planilha já existente com a `sheet_write()` e semelhantes.

Nesta seção trabalharemos com os mesmos conjuntos de dados utilizados na seção sobre arquivos do Excel para destacar semelhanças e diferenças entre o fluxo de trabalho de importação de dados do Excel e do Planilhas Google.
Os pacotes readxl e googlesheets4 foram desenhados para terem funcionalidades semelhantes ao pacote readr, o qual fornece a função `read_csv()` que você viu no @sec-data-import.
Existem muitas tarefas que podem ser realizadas apenas trocando `read_excel()` por `read_sheet()`.
Entretanto, você verá que o Excel e o Planilhas Google não se comportam extamente da mesma maneira, por isso, algumas chamadas de funções podem ser diferentes.

### Importando do Planilhas Google

A @fig-students-googlesheets mostra como é a planilha do Google que iremos importar para o R.
Este é o mesmo conjunto de dados da @fig-students-excel, exceto que está armazenado no Planilhas Google ao invés do Excel.

```{r}
#| label: fig-students-googlesheets
#| echo: false
#| fig-cap: |
#|   Planilha do Google chamada estudantes em uma janela do navegador.
#| fig-alt: |
#|   Uma visão da planilha estudantes no Planilhas Google. A planilha contém 
#|   informações de 6 estudantes, seus IDs, nomes completos, comida favorita, plano alimentar e  
#|   idade.

knitr::include_graphics("screenshots/import-googlesheets-students.png")
```

O primeiro argumento da `read_sheet()` é a URL do arquivo a ser importado, e a função retorna um tibble:\
<https://docs.google.com/spreadsheets/d/1V1nPp1tzOuutXFLb3G9Eyxi3qxeEhnOXUzL5_BcCQ0w>.
Estas URLs não são fáceis de se trabalhar, portanto frequentemente você irá preferir identificar uma planilha através do seu ID.

```{r}
gs4_deauth()
```

```{r}
#| cache: true
estudantes_planilha_id <- "1V1nPp1tzOuutXFLb3G9Eyxi3qxeEhnOXUzL5_BcCQ0w"
estudantes <- read_sheet(estudantes_planilha_id)
estudantes
```

Assim como fizemos na `read_excel()`, você pode fornecer nomes para as colunas, *strings* de valores não disponíveis (NA) e os tipos das colunas para a `read_sheet()`.

```{r}
#| cache: true
estudantes <- read_sheet(
  estudantes_planilha_id,
  col_names = c("estudante_id", "nome_completo", "comida_favorita", "refeicao_plano", "idade"),
  skip = 1,
  na = c("", "N/A"),
  col_types = "dcccc"
)

estudantes
```

Note que definimos os tipos das colunas de uma forma um pouco diferente aqui, usando códigos abreviados.
Por exemplo, "dcccc" significa "*double*, *character*, *character*, *character*, *character*".

Também é possível importar planilhas individuais do Planilhas Google.
Para importar somente a planilha "Ilha Torgersen" da [Planilha Pinguins do Planilhas Google](https://pos.it/r4ds-penguins):

```{r}
pinguins_planilha_id <- "1aFu8lnD_g0yjF5O-K6SFgSEWiHPpgvFCF0NY9D6LXnY"
read_sheet(pinguins_planilha_id, sheet = "Torgersen Island")
```

Você pode obter todos os nomes de planilhas de dentro de um arquivo do Planilhas Google com `sheet_names()`:

```{r}
sheet_names(pinguins_planilha_id)
```

Finalmente, assim como na `read_excel()`, podemos importar um intervalo de uma planilha definindo o argumento `range` na função `read_sheet()`.
Observe que também estamos utilizando a função `gs4_example()` para localizar a planilha de exemplo que vem junto com o pacote googlesheets4.

```{r}
obitos_url <- gs4_example("deaths")
obitos <- read_sheet(obitos_url, range = "A5:F15")
obitos
```

### Exportando para o Planilhas Google

Você pode exportar dados do R para o Planilhas Google com a função `write_sheet()`.
O primeiro argumento é o conjuntos de dados a ser exportado, o segundo argumento é o nome (ou outro identificador) da planilha a ser gravado no Planilhas Google:

```{r}
#| eval: false

write_sheet(doces_vendas, ss = "doces-vendas")
```

Se você quiser exportar para uma planilha específica dentro de um arquivo do Planilhas Google, você poderá fazê-lo especificando o argumento `sheet` também.

```{r}
#| eval: false

write_sheet(doces_vendas, ss = "doces-vendas", sheet = "Vendas")
```

### Autenticação

Apesar de você poder importar uma planilha pública com sua conta do Google e a função `gs4_deauth()`, importar uma planilha privada ou exportar para uma requer autenticação para que o pacote googlesheets4 possa acessar e gerenciar *suas* Planilhas Google.

Quando você tenta acessar uma planilha que requer autenticação, o googlesheets4 irá te redirecionar para um navegador web e pedir sua conta do Google para obter a permissão de operar as planilhas em seu lugar.
Entretanto, se você quiser definir uma conta específica, escopo de autenticação, etc, você pode fazer através da `gs4_auth()`, ex: `gs4_auth(email = "meu@exemplo.com")`, o qual irá forçar o uso de um *token* associado a este email específico.
Para mais informações sobre autenticação, recomendamos ler a documentação do googlesheets4 (*auth vignette*) em <https://googlesheets4.tidyverse.org/articles/auth.html>.

### Exercícios

1.  Importe o conjunto de dados `estudantes` visto anteriormente neste capítulo do Excel e do Planilhas Google, sem argumentos adicionais usando as funções `read_excel()` e `read_sheet()`.
    Os *data frames* resultantes são idênticos no R?
    Se não, quais as diferenças?

2.  Importe a planilha chamada pesquisa do Planilhas Google de <https://pos.it/r4ds-survey>, tendo `pesquisa_id` como uma variável texto (caractere) e `n_animais_estimacao` como numérica.

3.  Importe do Planilhas Google o arquivo chamado lista de <https://pos.it/r4ds-roster>.
    O *data frame* resultante deve se chamar `lista` e deve se parecer como mostrado abaixo.

    ```{r}
    #| echo: false
    #| message: false

    read_sheet("https://docs.google.com/spreadsheets/d/1LgZ0Bkg9d_NK8uTdP2uHXm07kAlwx8-Ictf8NocebIE/") |>
      fill(group, subgroup) |>
      print(n = 12)
    ```

## Resumo

O Microsoft Excel e o Planilhas Google são dois sistemas de planilhas muito populares.
Ser capaz de interagir com dados armazenados no Excel e Planilhas Google diretamente do R é um superpoder!
Neste capítulo você aprendeu a importar dados para o R de planilhas do Excel usando a `read_excel()` do pacote readxl e do Planilhas Google usando a `read_sheet()` do pacote googlesheets4.
Estas funções trabalham de forma muito parecidas e possuem argumentos similares para especificar nomes de colunas, valores não disponíveis (NA), pular linhas no início do arquivo que está importando, etc.
Além disso, ambas funções permitem ler planilhas específicas de dentro dos respectivos arquivos.

Por outro lado, exportar para o Excel requer um pacote e função diferente (`writexl::write_xlsx()`) enquanto você pode exportar para o Planilhas Google com o mesmo pacote googlesheets4, com a função `write_sheet()`.

No próximo capítulo, você aprenderá sobre uma fonte de dados diferente e como importar dados desta fonte para o R: banco de dados (*databases*).
