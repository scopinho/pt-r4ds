# Vetores lógicos {#sec-logicals}

```{r}
#| echo: false
#| results: asis

source("_common.R")

```

## Introdução

Neste capítulo, você aprenderá ferramentas para trabalhar com vetores lógicos.
Vetores lógicos são a forma mais simples de vetores, pois cada elemento pode ter apenas um dos três possíveis valores: `TRUE`, `FALSE` e `NA`.
É relativamente raro encontrar vetores lógicos em seus dados brutos, mas você os criará e manipulará no decorrer de quase todas as análises.

Começaremos discutindo a forma mais comum de criar vetores lógicos: por meio de comparações numéricas.
Em seguida, você aprenderá como usar a álgebra booleana para combinar diferentes vetores lógicos, bem como algumas sumarizações úteis.
Terminaremos com `if_else()` e `case_when()`, duas funções úteis para fazer alterações condicionais alimentadas por vetores lógicos.

### Pré-requisitos

A maioria das funções que você aprenderá neste capítulo são fornecidas pelo R base, então não precisamos do tidyverse, mas ainda assim iremos carregá-lo para que possamos usar `mutate()`, `filter()`, e demais funções para trabalhar com *data frames*.
Também continuaremos a extrair exemplos do conjunto de dados `dados::voos`.

```{r}
#| label: setup
#| message: false

library(tidyverse)
library (dados)
```

No entanto, à medida que começamos a estudar novas ferramentas, nem sempre haverá um exemplo real perfeito.
Então, começaremos a criar alguns dados fictícios com `c()`:

```{r}
x <- c(1, 2, 3, 5, 7, 11, 13)
x * 2
```

Isso facilita a explicação de funções individuais, ao custo de dificultar a visualização de como elas podem se aplicar aos seus problemas de dados.
Apenas lembre-se de que qualquer manipulação que fizermos em um vetor simples (*free-floating*), você poderá fazer em uma variável dentro de *data frame* com `mutate()` e demais funções amigas.

```{r}
df <- tibble(x)
df |> 
  mutate(y = x * 2)
```

## Comparações

Uma forma muito comum de criar um vetor lógico é através de uma comparação numérica usando `<`, `<=`, `>`, `>=`, `!=` e `==`.
Até agora, criamos principalmente variáveis ​​lógicas transitoriamente dentro de `filter()` --- elas são calculadas, usadas e depois jogadas fora.
Por exemplo, o filtro abaixo encontra todo os voos que sairam durante o dia e chegaram aproximadamente no horário:

```{r}
voos |> 
  filter(horario_saida > 600 & horario_saida < 2000 & abs(atraso_chegada) < 20)
```

É útil saber que isto é apenas um atalho e você pode explicitamente criar a variável lógica intrínseca com  `mutate()`:

```{r}
voos |> 
  mutate(
    diurno = horario_saida > 600 & horario_saida < 2000,
    aprox_no_horario = abs(atraso_chegada) < 20,
    .keep = "used"
  )
```

Isto é particularmente útil para lógicas mais complicadas, pois nomeando os passos intermediarios, se torna mais fácil tanto ler o código quanto verificar se cada passo está sendo calculado corretamente.

Com isto, o filtro inicial é equivalente a:

```{r}
#| results: false

voos |> 
  mutate(
    diurno = horario_saida > 600 & horario_saida < 2000,
    aprox_no_horario = abs(atraso_chegada) < 20,
  ) |> 
  filter(diurno & aprox_no_horario)
```

### Comparações com ponto-flutuante (*floating point*) {#sec-fp-comparison}

Cuidado ao usar `==` com números.
Por exemplo, parece que este vetor contém os números 1 e 2:

```{r}
x <- c(1 / 49 * 49, sqrt(2) ^ 2)
x
```

Mas se você fizer um teste de igualdade, você terá `FALSE`:

```{r}
x == c(1, 2)
```

O que está acontecendo aqui?
Os computadores armazenam números com um número fixo de casas decimais, então não há como representar exatamente 1/49 ou `sqrt(2)` e os cálculos subsequentes serão ligeiramente errados.
Podemos ver os valores exatos chamando `print()` com o argumento `digits`[^logicals-1]:

[^logicals-1]: R normalmente chama *print* para você (e.x. `x` é um atalho para `print(x)`), mas chamando-o explicitamente é útil se você quer fornecer outros argumentos.

```{r}
print(x, digits = 16)
```

Você pode ver porque o R arrendonda estes números por padrão: eles são realmente muito próximos ao que você espera.

Agora que você viu porque `==` falhou, o que você pode fazer a respeito?
Uma opção é usar `dplyr::near()` que ignora pequenas diferenças:

```{r}
near(x, c(1, 2))
```

### Valores faltantes (*missing values*) {#sec-na-comparison}

Os valores faltantes (*missing values) representam o desconhecido, portanto são "contagiosos": quase qualquer operações que envolva um valor desconhecido também será desconhecida:

```{r}
NA > 5
10 == NA
```

O resultado mais confuso é este:

```{r}
NA == NA
```

É mais fácil entender porque isto é verdadeiro se nós artificialmente fornecermos um pouco mais de contexto:

```{r}
# Não sabemos a idade de Maria
idade_maria <- NA

# Não sabemos a idade de João
idade_joao <- NA

# João e Maria tem a mesma idade?
idade_maria == idade_joao
# Não sabemos!
```

Portanto, se você quiser encontrar todos os voos onde `horario_saida` está faltando, o código a seguir não funciona, pois `horario_saida == NA` retorna `NA` para cada linha e `filter()` ignora automaticamente valores faltantes:

```{r}
voos |> 
  filter(horario_saida == NA)
```

Ao invés disso, vocè precisará de uma nova ferramenta: `is.na()`.

### `is.na()`

`is.na(x)` funciona com qualquer tipo de vetor e retorna `TRUE` para valores faltantes e `FALSE` para qualquer outra coisa:

```{r}
is.na(c(TRUE, NA, FALSE))
is.na(c(1, NA, 3))
is.na(c("a", NA, "b"))
```

Podemos usar `is.na()` para encontrar todos os registros com `horario_saida` faltando:

```{r}
voos |> 
  filter(is.na(horario_saida))
```

`is.na()` também pode ser útil em `arrange()`.
`arrange()` geralmente coloca todos os valores faltantes no final, mas você pode sobreescrever este padrão ordenando primeiro com `is.na()`:

```{r}
voos |> 
  filter(mes == 1, dia == 1) |> 
  arrange(horario_saida)

voos |> 
  filter(mes == 1, dia == 1) |> 
  arrange(desc(is.na(horario_saida)), horario_saida)
```

Retornaremos a cobrir mais detalhes sobre valores faltantes (*missing values*) no @sec-missing-values.

### Exercócio

1.  Como `dplyr::near()` funciona? Digite `near` para ver o código fonte. `sqrt(2)^2` é próximo (near) a 2?
2.  Use `mutate()`, `is.na()` e `count()` juntos para descrever como os valores faltantes (*missing values*) em `horario_saida`, `saida_programada` e `atraso_saida` estão relacionados.

## Algebra booleana

Quando você tem múltiplos vetores lógicos, você pode combiná-los usando algebra booleana.
No R, `&` é "e", `|` é "ou", `!` é "não" e `xor()` é ou exclusivo[^logicals-2].
Por exemplo, `df |> filter(!is.na(x))` encontra todas as linhas onde `x` está faltando e `df |> filter(x < -10 | x > 0)` encontra todas as linhas onde `x` é menor que -10 ou maior que 0.
A @fig-bool-ops mostra o conjunto completo de operações booleanas e como elas funcionam.

[^logicals-2]: Isto é, `xor(x, y)` é verdadeiro se x for verdadeiro, ou y for verdadeiro, mas nunca ambos.
    Isto é como usamos "ou" em Português.
    "Ambos" geralmente não é uma resposta aceitável quando respondemos a pergunta "Você gostaria de sorvete ou bolo?".

```{r}
#| label: fig-bool-ops
#| echo: false
#| out-width: NULL
#| fig-cap: | 
#|    O conjunto completo de operações booleanas. `x` é o círuclo da esquerda
#|    , `y` é o círculo da direita e a região preenchida mostra 
#|    qual parte cada operação seleciona.
#| fig-alt: |
#|    Seis diagramas de Venn, como um explicando um determinado operador lógico. Os
#|    círculos (conjunto) em cada diagrama de Venn representam x e y. 1. y &
#|    !x é y mas nada de x; x & y é a intersecção de de x e y; x & !y é
#|    x mas nada de y; x é tudo de x mas nada de y; xor(x, y) é tudo menos
#|    a interseccção de x e y; y é tudo de y e nada de x; e 
#|    x | y é tudo.
knitr::include_graphics("diagrams/transform.png", dpi = 270)
```

Além de `&` e `|`, o R também possui `&&` e `||`.
Não os use em funções dplyr!
Eles são chamados de operadores de curto-circuito e retornam sempre apenas um único `TRUE` ou `FALSE`.
Eles são importantes na programação, não em ciência de dados.

### Valore faltantes (*missing values*) {#sec-na-boolean}

As regras para valores ausentes na álgebra booleana são um pouco complicadas de explicar porque parecem inconsistentes à primeira vista:

```{r}
df <- tibble(x = c(TRUE, FALSE, NA))

df |> 
  mutate(
    e = x & NA,
    ou = x | NA
  )
```

Para entender o que está acontecendo aqui, pense em `NA | TRUE` (`NA` ou `TRUE`).
Um valor faltante (*missing value*) em um vetor lógico significa que o valor poderia ser `TRUE` ou `FALSE`.
`TRUE | TRUE` e `FALSE | TRUE` são ambos `TRUE` pois ao menos um dors termos é `TRUE`.
`NA | TRUE` também deve ser `TRUE` pois `NA` pode ser `TRUE` ou `FALSE`.
Ententando, `NA | FALSE` é `NA` pois não sabemos se `NA` é `TRUE` ou `FALSE`.
O mesmo se aplica com `NA & FALSE`.

### Order das operações

Observe que a ordem das operações não funcionam como em Português.
Veja o seguinte código que encotnra todos os voos que saíram em Novembro ou Dezembro:

```{r}
#| eval: false

voos |> 
   filter(mes == 11 | mes == 12)
```

Você pode estar tentado a escrevê-lo da forma que falaria em Português: "Encontre todos os voos que saíram em Novemebro e Dezembro.":

```{r}
voos |> 
   filter(mes == 11 | 12)
```

Este código não gera erro, mas também não parece ter funcionado.
O que acontece aqui?
Neste caso, o R calcula `mes == 11` criando um vetor lógico, o qual chamaremos de `nov`.
Então calcula `nov | 12`.
Quando usamos um número com um operador lógico, ele converte tudo exceto 0 para `TRUE`, o que é equivalente a `nov | TRUE` o que é sempre `TRUE`, então cada linha será selecionada:

```{r}
voos |> 
  mutate(
    nov = mes == 11,
    final = nov | 12,
    .keep = "used"
  )
```

### `%in%`

Um jeito fácil de evitar o problema de colocar `==`s e `|`s na order correta é usar `%in%`.
`x %in% y` retorna um vetor lógico de mesmo tamanho que `x` que é `TRUE` sempre que um valor em `x` está em qualquer lugar em `y` .

```{r}
1:12 %in% c(1, 5, 11)
letters[1:10] %in% c("a", "e", "i", "o", "u")
```

Portanto, para encontrar todos os voos de Novembro e Dezembro, poderíamos escrever:

```{r}
#| eval: false

voos |> 
  filter(mes %in% c(11, 12))
```

Note que `%in%` possui diferentes regras do `NA` para `==`, uma vez que `NA %in% NA` é `TRUE`.

```{r}
c(1, 2, NA) == NA
c(1, 2, NA) %in% NA
```

Isto pode ser um atalho útil:

```{r}
voos |> 
  filter(horario_saida %in% c(NA, 0800))
```

### Exercícios

1.  Encontre todos os voos onde `atraso_chegada` está faltando (*missing*), mas `atraso_saida` não. Encontre todos os voos onde nem `horario_chegada` ou `chegada_prevista` estão faltando, mas `atraso_chegada` está.
2.  Quantos voos possuem `horario_saida` faltando? Quais outras variáveis possuem valores faltantes nestes registros? O que podem representar estas linhas?
3.  Assumindo que um valor faltante em `horario_saida` implica em um voo cancelado, olhe o número de voos cancelados por dia. Há algum padrão? Há alguma relação entre a proporção de voos cancelados e a média de atraso dos voos não cancelados?

## Sumarização {#sec-logical-summaries}

As seções a seguir descrevem técnicas úteis para sumarização de vetores lógicos.
Assim como funções que trabalham especificamente com vetores lógicos, você também pode usar funções que trabalham com vetores numéricos.

### Sumarizações lógicas

Existem dois sumarizadores lógicos: `any()` e `all()`.
`any(x)` é o equivalente ao `|`; retornará `TRUE` se houver algum `TRUE` em `x`.
`all(x)` é o equivalente ao `&`; retornará `TRUE` somente se todos os valores de `x` forem `TRUE`.
Assim como todas as funções de sumarização, elas retornarão `NA` se houver qualquer valor faltante (*missing value*) presente, e como de costume, você pode não considerá-los usando `na.rm = TRUE`.

Por exemplo, poderíamos usar `all()` e `any()` para encontrar se todos os voos que atrasaram no máximo uma hora na saída ou se algum voo atrasou na chegada cinco horas ou mais.
And using `group_by()` allows us to do that by day:

```{r}
voos |> 
  group_by(ano, mes, dia) |> 
  summarize(
    todos_atrasados = all(atraso_saida <= 60, na.rm = TRUE),
    algum_atraso_longo = any(atraso_chegada >= 300, na.rm = TRUE),
    .groups = "drop"
  )
```

Na maioria dos casos, entretanto, `any()` e `all()` são um tanto grosseiros, e seria bom poder obter mais detalhes sobre os valores `TRUE` ou `FALSE`.
Isso nos leval aos sumarizadores numéricos.

### Sumarizações numéricas de vetores lógicos {#sec-numeric-summaries-of-logicals}

Quando você usa um vetor lógico em um contexto numérico, `TRUE` se torna 1 e `FALSE` se torna 0.
Isto torna `sum()` e `mean()` muito úteis com vetores lógicos, pois `sum(x)` retorna o número de `TRUE`s e `mean(x)` retorna a proporção de `TRUE`s (pois `mean()` é apenas `sum()` dividido por`length()`).

Isto, por exemplo, nos permite ver a proporção de voos que tiveram atraso na saída em até uma hora e o número de voos que chegaram atrasados em cinco horas ou mais.:

```{r}
voos |> 
  group_by(ano, mes, dia) |> 
  summarize(
    todos_atrasados = mean(atraso_saida <= 60, na.rm = TRUE),
    algum_atraso_longo = sum(atraso_chegada >= 300, na.rm = TRUE),
    .groups = "drop"
  )
```

### Subconjunto (*subsetting*) lógico

Existe ainda um último uso de vetores lógicos em sumarizações: você pode usar um vetor lógico para filtrar uma única variável em um subconjunto (*subset*) de interesse.
Isto faz uso do operador do R base `[` (se pronuncia *subset*), o qual você aprenderá mais na @sec-subset-many.

Imagine que gostaríamos de encontrar a média de atraso somente de voos que realmente estiveram atrasados.
Uma forma de fazê-lo seria primeiro filtrar os voos e depois calcular a média de atraso:

```{r}
voos |> 
  filter(atraso_chegada > 0) |> 
  group_by(ano, mes, dia) |> 
  summarize(
    atraso_medio = mean(atraso_chegada),
    n = n(),
    .groups = "drop"
  )
```

Isto funciona, mas e se você quisesse calcular o atraso médio também para voos que chegaram antecipadamente?
Precisaríamos fazer um passo extre de filtro e então combinar os dois *data frames*[^logicals-3].
Ao invés disso, você poderia usar `[` para executar um filtro em linha (*inline*): `atraso_chegada[atraso_chegada > 0]` irá retornar apenas os atrasos positivos na chegada.

[^logicals-3]: Iremos cobrir isto na @sec-joins.

This leads to:

```{r}
voos |> 
  group_by(ano, mes, dia) |> 
  summarize(
    atrasado = mean(atraso_chegada[atraso_chegada > 0], na.rm = TRUE),
    antecipado = mean(atraso_chegada[atraso_chegada < 0], na.rm = TRUE),
    n = n(),
    .groups = "drop"
  )
```

Observe também a diferença no tamanho do grupo: no primeiro segmento `n()` tem o número de voos em atraso por dia, no segundo, `n()` retorna o número total de voos.

### Exercises

1.  Que `sum(is.na(x))` diz a você? E `mean(is.na(x))`?
2.  O que `prod()` returna quando aploicada a um vetor lógico? Qual função de sumarização lógica é equivalente? O que `min()` returna quando aplicada a um vetor lógico? Qual função de sumarização lógica é equivalente? Leia a documentação e efetue alguns experimentos.

## Transformações condicionais

Uma das características mais poderosas de vetores lógico é seu uso em transformações condicionais, i.x. fazer alguma coisa em uma condição x, e alguma outra coisa diferente para a y.
Existem duas ferramentas importantes para isso: `if_else()` e `case_when()`.

### `if_else()`

Se você quiser usar um valor para quando a condição é `TRUE` e outro valor para quando a condição é `FALSE`, você pode usar `dplyr::if_else()`[^logicals-4].
Você sempre usará os primeiros três argumentos de `if_else()`. O primeiro, `condition`, é um vetor lógico, o segundo, `true`, gera uma saída quando a condiçção é verdadeira (*true*) , e o terceiro, `false`, gera uma saída quando a condição é falsa (*false*).

[^logicals-4]: A função `if_else()` do dplyr é muito similar a `ifelse()` do R base .
    Existem duas vantagens principais do `if_else()` sobre `ifelse()`: você pode escolhar o que acontece com valor faltantes (*minssing values*) e `if_else()` te retorna erros com mais sentido se sua variável possuir tipos incompatíveis.

Vamos começar com um simples exemplo rotulando um vetor numérico como "+vo" (positivo) ou "-vo" (negativo):

```{r}
x <- c(-3:3, NA)
if_else(x > 0, "+vo", "-vo")
```

Há um quarto argumento opcional, `missing` o qual pode ser usado se a entrada for um valor `NA`:

```{r}
if_else(x > 0, "+vo", "-vo", "???")
```

Você também usar vetores para os argumentos `true` e `false`.
Por exemplo, isto nos permite criar uma implmentação mínima de `abs()`:

```{r}
if_else(x < 0, -x, x)
```

Até agora, todos os argumentos usaram os mesmos vetores, mas você pode misturar e combinar isso.
Por exemplo, você pode implementar uma versão simples de `coalesce()` desta forma:

```{r}
x1 <- c(NA, 1, 2, NA)
y1 <- c(3, NA, 4, 6)
if_else(is.na(x1), y1, x1)
```

Você pode notar uma pequena infelicidade em nosso exemplo de rótulo acima: zero não é nem positivo nem negativo.
Nós poderíamos resolver isso adicionando um novo `if_else()`:

```{r}
if_else(x == 0, "0", if_else(x < 0, "-vo", "+vo"), "???")
```

Isto já é um pouco difícil de ler, mas você pode imaginar como se tornaria mais difícil se você tiver mais ainda mais condições.
Ao invés disso, você deve mudar para o `dplyr::case_when()`.

### `case_when()`

O `case_when()` do pacote dplyr é inspirado pela declaração `CASE` do SQL e oferece uma forma flexível de efetuar diferentes cálculos para diferentes condições.
Infelizmente, ele tem uma sintaxe que não se parece com nada que você usará no pacote tidyverse.
Ele recebe pares que se parecem com `condição ~ saída`.
`condição` deve ser um vetor lógico; quando for `TRUE`, `saída` será usada.

Isto significa que poderíamos recriar nos `if_else()` aninhado dest forma:

```{r}
x <- c(-3:3, NA)
case_when(
  x == 0   ~ "0",
  x < 0    ~ "-vo", 
  x > 0    ~ "+vo",
  is.na(x) ~ "???"
)
```

O código é maior, mas também é mais explícito.

Para explicar com `case_when()` funciona, vamos explorar mais alguns casos mais simples.
Se nenhum dos casos correponder, a saída será `NA`:

```{r}
case_when(
  x < 0 ~ "-vo",
  x > 0 ~ "+vo"
)
```

Use `.default` se você quiser gerar um "padrão"/pega todos valores:

```{r}
case_when(
  x < 0 ~ "-vo",
  x > 0 ~ "+vo",
  .default = "???"
)
```

E observe que se várias condições corresponderem, apenas a primeira será usada:

```{r}
case_when(
  x > 0 ~ "+vo",
  x > 2 ~ "grande"
)
```

Assim como com `if_else()` você pode usar variáveis ​​em ambos os lados do `~` e pode misturar e combinar variáveis ​​conforme necessário para o seu problema.
Por exemplo, poderíamos usar `case_when()` para fornecer alguns rótulos legíveis para o atraso de chegada:

```{r}
voos |> 
  mutate(
    status = case_when(
      is.na(atraso_chegada)      ~ "cancelado",
      atraso_chegada < -30       ~ "muito antecipado",
      atraso_chegada < -15       ~ "antecipado",
      abs(atraso_chegada) <= 15  ~ "no horario",
      atraso_chegada < 60        ~ "atrasado",
      atraso_chegada < Inf       ~ "muito atrasdo",
    ),
    .keep = "used"
  )
```

Tenha cuidado ao escrever esse tipo de instrução `case_when()` complexa; minhas duas primeiras tentativas usaram uma mistura de `<` e `>` e continuei criando acidentalmente condições sobrepostas.

### Tipos compatíveis

Observe que `if_else()` e `case_when()` requerem tipos **compatíveis** na saída.
Se eles não forem compatíveis, você verá erros como este:

```{r}
#| error: true

if_else(TRUE, "a", 1)

case_when(
  x < -1 ~ TRUE,  
  x > 0  ~ now()
)
```

No geral, relativamente poucos tipos são compatíveis, porque a conversão automática de um tipo de vetor em outro é uma fonte comum de erros.
Aqui estão os casos mais importantes que são compatíveis:

-   Vetores numéricos e lógicos são compatíveis, conforme discutimos na @sec-numeric-summaries-of-logicals.
-   Strings e fatores (@sec-factors) são compatíveis, porque você pode pensar em um fator como uma string com um conjunto restrito de valores.
-   Datas e datas e horas, que discutiremos no @sec-dates-and-times, são compatíveis porque você pode pensar em uma data (*date*) como um caso especial de data_hora (*datetime*).
-   `NA`, que é tecnicamente um vetor lógico, é compatível com tudo porque todo vetor tem alguma forma de representar um valor faltante (*missing value*).

Não esperamos que você memorize essas regras, mas elas devem se tornar naturais com o tempo, porque são aplicadas de forma consistente em todo o tidyverse.

### Exercícios

1.  Um número é par se for divisível por dois, o que, no R, você pode descobrir com `x %% 2 == 0`.
    Use este fato e `if_else()` para determinar se cada número entre 0 e 20 é par ou ímpar.

2.  Dado um vetor de dias como `x <- c("Segunda-feira", "Sábado", "Quarta-feira")`, use uma instrução `ifelse()` para rotulá-los como fins de semana ou dias de semana.

3.  Use `ifelse()` para calcular o valor absoluto de um vetor numérico chamado `x`.

4.  Escreva uma declaração `case_when()` que usa as colunas `mes` e `dia` de `voos` para rotular um conjunto de feriados importante dos Estados Unidos (e.g., Dia de Ano Novo, 4 de Julho, Dia de Ação de Graças e Natal).
    Primeiro crie uma coluna lógica `TRUE` ou `FALSE`, e então uma coluna texto (*character*) que tenha o nome do feriado ou `NA`.

## Resumo

A definição de vetor lógico é simples pois seu valor é `TRUE`, `FALSE` ou `NA`.
Mas os vetores lógicos oferecem grande poder.
Neste capítulo, você aprendeu a criar vetores lógicos com `>`, `<`, `<=`, `>=`, `==`, `!=` e `is.na()`, como combiná-los com `!`, `&` e `|`, e como sumarizá-los com `any()`, `all()`, `sum()` e `mean()`.
Você também aprendeu as funções poderosas `if_else()` e `case_when()` que permitem você retornar valores dependendo do valor de um vetor lógico.

Veremos vetores lógicos cada vez mais nos próximos capítulos.
Por exemplo, no @sec-strings você vai aprender sobre `str_detect(x, pattern)` que retorna um vetor lógico que será `TRUE` para elementos de `x` que correnpondem ao `pattern` (padrão), e no @sec-dates-and-times você irá criar vetores lógicos a partir de comparações de datas e horários.
Por ora, iremos para o próximo mais importante tipo de vetores: vetores numéricos.
