# Datas e horários {#sec-dates-and-times}

```{r}
#| echo: false
#| results: asis
source("_common.R")


# https://github.com/tidyverse/lubridate/issues/1058
options(warnPartialMatchArgs = FALSE)
```

## Introdução

Este capítulo mostrará como trabalhar com datas e horários (*dates and times*) no R.
À primeira vista, datas e horários parecem simples.
Você os utiliza o tempo todo em sua vida normal e eles não parecem causar muita confusão.
Porém, quanto mais você aprende sobre datas e horários, mais complicados eles parecem ficar!

Para aquecer os motores, pense em quantos dias tem um ano e quantas horas tem um dia.
Você provavelmente se lembrou que a maioria dos anos tem 365 dias, mas os anos bissextos têm 366.
Você conhece a regra completa para determinar se um ano é bissexto[^datetimes-1]?
O número de horas em um dia é um pouco menos óbvio: a maioria dos dias tem 24 horas, mas em locais que usam o horário de verão (*Day Light Saving - DST*), um dia de cada ano tem 23 horas e outro tem 25 horas.

[^datetimes-1]: Um ano é bissexto se for divisível por 4, a menos que também seja divisível por 100, exceto se também for divisível por 400.
    Em outras palavras, em cada conjunto de 400 anos, há 97 anos bissextos.

Datas e horários são difíceis porque têm de conciliar dois fenômenos físicos (a rotação da Terra e a sua órbita em torno do Sol) com uma série de fenômenos geopolíticos, incluindo meses, fusos horários e horário de verão.
Este capítulo não ensinará todos os detalhes sobre datas e horários, mas fornecerá uma base sólida de habilidades práticas que te ajudarão com desafios comuns de análise de dados.

Começaremos mostrando como criar datas e horários a partir de várias entradas e, depois de obter uma data e horário, como extrair componentes como ano, mês e dia.
Em seguida, mergulharemos no tópico complicado de trabalhar com intervalos de tempo (*time span*), que vêm em uma variedade de sabores, dependendo do que você está tentando fazer.
Concluiremos com uma breve discussão sobre os desafios adicionais colocados pelos fusos horários.

### Pré-requisitos

Este capítulo se concentrará no pacote **lubridate**, que facilita o trabalho com datas e horários no R.
Na versão mais recente do tidyverse, o lubridate passou a ser um componente principal do tidyverse.
Para praticar, também precisaremos do conjunto de dados voos do pacote dados.

```{r}
#| message: false
library(tidyverse)
library(dados)
```

## Criando datas/horários {#sec-creating-datetimes}

Existem três tipos de dados de data/horário que se referem a um instante no tempo:

-   Um **date** (data).
    Os tibbles imprimem este tipo como `<date>`.

-   Um **time** (horário) dentro de um dia.
    Os tibbles imprimem este tipo como `<time>`.

-   Um **date-time** (data-horário) que é uma data mais um horário: Identifica unicamente um instante no tempo (tipicamente arredondado ao segundo mais próximo).
    Os tibbles imprimem este tipo como `<dttm>`.
    O R base chama este tipo de POSIXct, mas sem enrolar a língua.

Neste capítulo iremos nos concentrar em data (*date*) e data-horário (*date-time*), já que o R não possui uma classe nativa para lidar apenas com horário (*time*).
Se você precisar de uma, pode usar o pacote **hms**.

Você deve sempre usar o tipo de dados mais simples possível que atenda às suas necessidades.
Isso significa que se você puder usar uma data (*date*) em vez de um data-horário (*date-time*), você deveria.
O tipo data-horário é substancialmente mais complicado devido à necessidade de lidar com fusos horários, aos quais voltaremos no final do capítulo.

Para obter a data ou data-horário atual, você pode usar `today()` ou `now()`:

```{r}
today()
now()
```

Caso contrário, as seções a seguir descrevem as quatro maneiras pelas quais você provavelmente criará uma data/horário:

-   Ao ler um arquivo com readr.
-   De uma cadeia de caracteres (*string*).
-   De componentes individuais de data-horário.
-   De um objeto data/horário.

### Durante a importação

Se seu CSV contém uma data ou data-horário no padrão ISO8601, você não precisa fazer nada, o readr o reconhece automaticamente:

```{r}
#| message: false
csv <- "
  date,datetime
  2022-01-02,2022-01-02 05:12
"
read_csv(csv)
```

Se você nunca ouviu falar de **ISO8601** antes, é um padrão internacional[^datetimes-2] para escrever datas onde os componentes de uma data são organizados do maior para o menor, separados por `-`. Por exemplo, na ISO8601, 3 de maio de 2022 é `2022-05-03`. As datas ISO8601 também podem incluir horários, onde hora, minuto e segundo são separados por `:`, e os componentes de data e horário são separados por um `T` ou um espaço.
Por exemplo, você pode escrever 16:26 do dia 3 de maio de 2022 como `2022-05-03 16:26` ou `2022-05-03T16:26.

[^datetimes-2]: <https://xkcd.com/1179/>

Para outros formatos de data e horário, você precisará usar `col_types` com`col_date()` ou `col_datetime()` junto com um formato de data e horário.
O formato de data e horário usado por readr é um padrão usado em muitas linguagens de programação, descrevendo um componente de data com um `%` seguido por um único caractere.
Por exemplo, `%Y-%m-%d` especifica uma data que é um ano, `-`, mês (como número) `-`, dia.
A tabela @tbl-date-formats lista todas as opções.

| Type    | Code  | Meaning                             | Example         |
|---------|-------|-------------------------------------|-----------------|
| Ano     | `%Y`  | Ano com 4 digitos                    | 2021            |
|         | `%y`  | Ano com 2 digitos                    | 21              |
| Mês     | `%m`  | Número                              | 2               |
|         | `%b`  | Nome abreviado                      | Feb             |
|         | `%B`  | Nome completo                       | February        |
| Dia     | `%d`  | Um ou dois digitos                  | 2               |
|         | `%e`  | Dois digitos                        | 02              |
| Horário | `%H`  | Horas em 24-horas                   | 13              |
|         | `%I`  | Horas em 12-horas                   | 1               |
|         | `%p`  | AM/PM                               | pm              |
|         | `%M`  | Minutos                             | 35              |
|         | `%S`  | Segundos                            | 45              |
|         | `%OS` | Seconds com decimal                 | 45.35           |
|         | `%Z`  | Nome fuso horário                   | America/Chicago |
|         | `%z`  | Ajuste (*offset*) de UTC            | +0800           |
| Outras  | `%.`  | Pula um não digito                  | :               |
|         | `%*`  | Pula qualquer número de não digito  |                 |

: Todos os formatos de datas compreendidos pelo readr {#tbl-date-formats}

E este código mostra algumas opções aplicadas a uma data muito ambígua:

```{r}
#| messages: false

csv <- "
  date
  01/02/15
"

read_csv(csv, col_types = cols(date = col_date("%m/%d/%y")))

read_csv(csv, col_types = cols(date = col_date("%d/%m/%y")))

read_csv(csv, col_types = cols(date = col_date("%y/%m/%d")))
```

Observe que não importa como você especifica o formato da data, ela sempre será exibida da mesma maneira quando você o inserir no R.

Se você estiver usando `%b` ou `%B` e trabalhando com datas que não sejam em inglês, você também precisará fornecer uma localização com a função `locale()`.
Veja a lista de idiomas disponíveis em `date_names_langs()` ou crie o seu próprio com `date_names()`

### A partir de *strings*

A linguagem de especificação de data e horário é poderosa, mas requer uma análise cuidadosa do formato da data.
Uma abordagem alternativa é usar os auxiliares do pacote lubridate que tentam determinar automaticamente o formato assim que você especifica a ordem do componente.
Para usá-los, identifique a ordem em que ano (*year*), mês (*month*) e dia (*day*) aparecem em suas datas e organize "y", "m" e "d" na mesma ordem.
Isso lhe dá o nome da função lubridate que interpretará sua data.
Por exemplo:

```{r}
ymd("2017-01-31")
mdy("January 31st, 2017")
dmy("31-Jan-2017")
```

`ymd()` e funções similares criam datas.
Para criar uma data e horário, adicione um sublinhado e um ou mais "h", "m" e "s" (*hour*, *minute*, *seconds*) ao nome da função de análise:

```{r}
ymd_hms("2017-01-31 20:11:59")
mdy_hm("01/31/2017 08:01")
```

Você também pode forçar a criação de uma data e horário a partir de uma data, fornecendo um fuso horário:

```{r}
ymd("2017-01-31", tz = "UTC")
```

Aqui eu uso o fuso horário UTC[^datetimes-3] que você também pode conhecer como GMT, ou Greenwich Mean Time, o horário em 0° de longitude[^datetimes-4]
. Ele não usa o horário de verão, o que torna os cálculos um pouco mais simples.

[^datetimes-3]: Você pode estar se perguntando o que UTC significa.
    É uma mistura entre o termo em inglês "Coordinated Universal Time" e o francês "Temps Universel Coordonné".

[^datetimes-4]: Não há prêmios por adivinhar qual país criou o sistema de longitude.

### A partir de componentes individuais

Em vez de uma única *string*, às vezes você terá os componentes individuais da data e horário espalhados por várias colunas.
Isto é o que temos nos dados de `vôos`:

```{r}
voos |> 
  select(ano, mes, dia, hora, minuto)
```

Para criar uma data/horário a partir deste tipo de entrada, use a `make_date()` para datas, or `make_datetime()` for data-horário:

```{r}
voos |> 
  select(ano, mes, dia, hora, minuto) |> 
  mutate(saida = make_datetime(ano, mes, dia, hora, minuto))
```

Vamos fazer a mesma coisa para cada uma das quatro colunas de tempo em `voos`.
Os horários são representados em um formato particular, por isso usamos a aritmética de módulo para extrair os componentes de hora e minuto.
Depois de criarmos as variáveis ​​de data e horário, nos concentraremos nas variáveis ​​que exploraremos no restante do capítulo.

```{r}
cria_datahorario_100 <- function(ano, mes, dia, horario) {
  make_datetime(ano, mes, dia, horario %/% 100, horario %% 100)
}

voos_dt <- voos |> 
  filter(!is.na(horario_saida), !is.na(horario_chegada)) |> 
  mutate(
    horario_saida = cria_datahorario_100(ano, mes, dia, horario_saida),
    horario_chegada = cria_datahorario_100(ano, mes, dia, horario_chegada),
    saida_programada = cria_datahorario_100(ano, mes, dia, saida_programada),
    chegada_prevista = cria_datahorario_100(ano, mes, dia, chegada_prevista)
  ) |> 
  select(origem, destino, starts_with("atraso"), ends_with("prevista"), ends_with("programada"), starts_with("horario"), tempo_voo)

voos_dt
```

Com esses dados, podemos visualizar a distribuição dos horários de saída ao longo do ano:

```{r}
#| fig.alt: >
#|   Um gráfico de polígono de frequência com horário de saída (janeiro-dezembro de 2013) no eixo-x
#|   e número de voos no eixo-y (0-1000). O polígono de frequência
#|   é agrupado por dia para que você veja uma série temporal de voos por dia. O
#|   o padrão é dominado por um padrão semanal; há menos voos 
#|   nos fins de semana. São poucos os dias que se destacam por terem tido surpreendentemente
#|   poucos voos no início de fevereiro, início de julho, final de novembro e final de
#|   dezembro.
voos_dt |> 
  ggplot(aes(x = horario_saida)) + 
  geom_freqpoly(binwidth = 86400) # 86400 segundos = 1 dia
```

Ou dentro de um único dia:

```{r}
#| fig.alt: >
#|   Um polígono de frequência com horário de partida (6h - meia-noite de 1º de janeiro) no
#|   eixo x, número de voos no eixo y (0-17), agrupados em incrementos de 10 minutos.
#|   É difícil ver muitos padrões devido à alta variabilidade,
#|   mas a maioria dos grupos tem de 8 a 12 voos, e há significativamente menos voos 
#|   antes das 6h e depois das 20h.
voos_dt |> 
  filter(horario_saida < ymd(20130102)) |> 
  ggplot(aes(x = horario_saida)) + 
  geom_freqpoly(binwidth = 600) # 600 s = 10 minutos
```

Observe que quando você usa data e horário (*datatime*) em um contexto numérico (como em um histograma), 1 significa 1 segundo, portanto, uma largura de um grupo de 86.400 significa um dia.
Para datas (*date*), 1 significa 1 dia.

### A partir de outros tipos

Você pode querer alternar entre uma data e horário (*datatimes*) e uma data (*date*).
Esse é o trabalho ds funções `as_datetime()` e `as_date()`:

```{r}
as_datetime(today())
as_date(now())
```

Às vezes, você obterá datas/horários como deslocamentos (*offsets*) numéricos a partir da "Era Unix" (*Unix Epoch*), 01/01/1970.
Se o deslocamento (*offset*) estiver em segundos, use `as_datetime()`; se for em dias, use `as_date()`.

```{r}
as_datetime(60 * 60 * 10)
as_date(365 * 10 + 2)
```

### Exercícios

1.  O que acontece se você analisar uma *string* que contém datas inválidas?

    ```{r}
    #| eval: false

    ymd(c("2010-10-10", "bananas"))
    ```

2.  O que o argumento `tzone` para a função `today()` faz?
    Por que ele é importante?

3.  Para cada uma das seguintes datas e horários, mostre como você as analisaria usando uma especificação de coluna readr e uma função lubridate.

    ```{r}
    d1 <- "January 1, 2010"
    d2 <- "2015-Mar-07"
    d3 <- "06-Jun-2017"
    d4 <- c("August 19 (2015)", "July 1 (2015)")
    d5 <- "12/30/14" # Dez 30, 2014
    t1 <- "1705"
    t2 <- "11:15:10.12 PM"
    ```

## Componentes de data-horário 

Agora que você sabe como inserir dados de data e horário (*date time*) nas estruturas de dados de data e horário do R, vamos explorar o que você pode fazer com eles.
Esta seção se concentrará nas funções que permitem obter e definir componentes individuais.
A próxima seção abordará como a aritmética funciona com datas e horários.

### Obtendo os componentes

Você pode extrair partes individuais da data com as funções de acesso `year()`, `month()`, `mday()` (dia do mês), `yday()` (dia do ano), ` wday()` (dia da semana), `hora()`, `minuto()` e `segundo()`.
Estes são efetivamente os opostos de `make_datetime()`.

```{r}
data_horario <- ymd_hms("2026-07-08 12:34:56")

year(data_horario)
month(data_horario)
mday(data_horario)

yday(data_horario)
wday(data_horario)
```

Para `month()` e `wday()` você pode definir `label = TRUE` para retornar o nome abreviado do mês ou dia da semana.
Defina `abbr = FALSE` para retornar o nome completo.

```{r}
month(data_horario, label = TRUE)
wday(data_horario, label = TRUE, abbr = FALSE)
```

Podemos usar `wday()` para ver que mais voos saem durante a semana do que no fim de semana:

```{r}
#| fig-alt: |
#|   Um gráfico de barras com os dias da semana no eixo x e o número de 
#|   vôos no eixo y. De segunda a sexta-feira têm aproximadamente o mesmo número de
#|   voos, ~48.0000, diminuindo ligeiramente ao longo da semana.
#|   Domingo é um pouco menor (~45.000) e sábado é muito menor 
#|   (~38,000).
voos_dt |> 
  mutate(dia_semana = wday(horario_saida, label = TRUE)) |> 
  ggplot(aes(x = dia_semana)) +
  geom_bar()
```

Também podemos observar o atraso médio de partida por minuto dentro de uma hora.
Há um padrão interessante: os voos que partem nos minutos 20-30 e 50-60 têm atrasos muito menores do que no resto da hora!

```{r}
#| fig-alt: | 
#|   Um gráfico de linhas com o minuto da saída real (0-60) no eixo x e
#|   atraso médio (4-20) no eixo y. O atraso médio começa em (0, 12),
#|   aumenta constantemente para (18, 20), depois cai drasticamente, atingindo o mínimo
#|   aproximadamente 23 minutos após a hora e 9 minutos de atraso. Então aumenta
#|   novamente para (17, 35) e diminui acentuadamente para (55, 4). Isso acaba
#|   com um aumento para (60, 9).
voos_dt |> 
  mutate(minuto = minute(horario_saida)) |> 
  group_by(minuto) |> 
  summarize(
    atraso_medio = mean(atraso_saida, na.rm = TRUE),
    n = n()
  ) |> 
  ggplot(aes(x = minuto, y = atraso_medio)) +
  geom_line()
```

Curiosamente, se olharmos para o horário de saída *programado*, não veremos um padrão tão forte:

```{r}
#| fig-alt: | 
#|   A line chart with minute of scheduled departure (0-60) on the x-axis
#|   and average delay (4-16). There is relatively little pattern, just a
#|   small suggestion that the average delay decreases from maybe 10 minutes
#|   to 8 minutes over the course of the hour.
saida_programada <- voos_dt |> 
  mutate(minuto = minute(saida_programada)) |> 
  group_by(minuto) |> 
  summarize(
    atraso_medio = mean(atraso_chegada, na.rm = TRUE),
    n = n()
  )

ggplot(saida_programada, aes(x = minuto, y = atraso_medio)) +
  geom_line()
```

Então, por que vemos esse padrão nos horários reais de partida?
Bem, como muitos dados coletados por humanos, há uma forte tendência em relação aos voos que partem em horários de partida "agradáveis", como mostra a @fig-human-rounding.
Esteja sempre alerta para esse tipo de padrão sempre que trabalhar com dados que envolvam julgamento humano!

```{r}
#| label: fig-human-rounding
#| fig-cap: |
#|   Um gráfico de polígono de frequência mostrando o número de voos programados
#|   para partir a cada hora. Você pode ver uma forte preferência por números redondos
#|   como 0 e 30 e geralmente para números múltiplos de cinco.
#| fig-alt: |
#|   Um gráfico de linha com minuto de partida (0-60) no eixo-x e número de
#|   voos (0-60000) no eixo y. A maioria dos voos está programada para partir
#|   na hora (~60.000) ou na meia hora (~35.000). De outra forma,
#|   quase todos os voos estão programados para partir em múltiplos de cinco,
#|   com alguns extras aos 15, 45 e 55 minutos.
#| echo: false
ggplot(saida_programada, aes(x = minuto, y = n)) +
  geom_line()
```

### Arredondamento

Uma abordagem alternativa para plotar componentes individuais é arredondar a data para uma unidade de tempo próxima, com `floor_date()`, `round_date()` e `ceiling_date()`.
Cada função tem como argumento um vetor de datas para ajustar e o nome da unidade de tempo para arredondar para baixo (*floor*), para cima (*ceiling*) ou para simplesmente arredondar para a data sem mover para cima ou para baixo.
Isto, por exemplo, permite-nos criar um gráfico com o número de voos por semana:

```{r}
#| fig-alt: |
#|   Um gráfico de linhas com a semana (janeiro-dezembro de 2013) no eixo x e o número de
#|   voos (2.000-7.000) no eixo y. O padrão é razoavelmente uniforme entre
#|   fevereiro e novembro, com cerca de 7.000 voos por semana. Há
#|   muito menos voos na primeira (aproximadamente 4.500 voos) e na última
#|   semanas do ano (aproximadamente 2.500 voos).
voos_dt |> 
  count(semana = floor_date(horario_saida, "week")) |> 
  ggplot(aes(x = semana, y = n)) +
  geom_line() + 
  geom_point()
```

Você pode usar o arredondamento para visualizar a distribuição de voos ao longo de um dia, calculando a diferença entre `horario_saida` e o primeiro instante daquele dia:

```{r}
#| fig-alt: |
#|   Um gráfico de linha com tempo de partida no eixo x. Isto é, unidades de segundos
#|   desde meia-noite, então é difícil de interpretar.
voos_dt |> 
  mutate(hora_saida = horario_saida - floor_date(horario_saida, "day")) |> 
  ggplot(aes(x = hora_saida)) +
  geom_freqpoly(binwidth = 60 * 30)
```

Calcular a diferença entre um par de variáveis data-horário produz um objeto *difftime* (mais sobre isso na @sec-intervals).
Podemos converter isso em um objeto `hms` para obter um eixo x mais útil:

```{r}
#| fig-alt: |
#|   Um gráfico de linha com horário de saída (meia-noite à meia-noite) no eixo x
#|   e número de voos no eixo-y (0 a 15.000). Há muito poucos
#|   (<100) voos antes das 5h. O número de voos aumenta rapidamente 
#|   para 12.000/hora, com pico de 15.000 às 9h, antes de cair para cerca de
#|   8.000 / hora das 10h às 14h. O número de voos aumenta então para
#|   cerca de 12.000 por hora até as 20h, quando voltam a cair rapidamente. 
voos_dt |> 
  mutate(hora_saida = hms::as_hms(horario_saida - floor_date(horario_saida, "day"))) |> 
  ggplot(aes(x = hora_saida)) +
  geom_freqpoly(binwidth = 60 * 30)
```

### Modificando componentes

Você também pode usar cada função de acesso para modificar os componentes de uma data/horário.
Isso não aparece muito na análise de dados, mas pode ser útil ao limpar dados que possuem datas que claramente estão incorretas.

```{r}
(data_horario <- ymd_hms("2026-07-08 12:34:56"))

year(data_horario) <- 2030
data_horario
month(data_horario) <- 01
data_horario
hour(data_horario) <- hour(data_horario) + 1
data_horario
```

Alternativamente, em vez de modificar uma variável existente, você pode criar uma nova data e hora com `update()`.
Isso também permite que você defina vários valores em uma única etapa:

```{r}
update(data_horario, year = 2030, month = 2, mday = 2, hour = 2)
```

Se os valores forem muito grandes, eles serão acumulados:

```{r}
update(ymd("2023-02-01"), mday = 30)
update(ymd("2023-02-01"), hour = 400)
```

### Exercícios

1.  Como a distribuição dos tempos de voo dentro de um dia muda ao longo do ano?

2.  Compare `horario_saida`, `saida_programada` e `atraso_saida`.
    Eles são consistentes?
    Explique suas descobertas.

3.  Compare `tempo_voo` com a duração entre a saída e a chegada.
    Explique suas descobertas.
    (Dica: considere a localização do aeroporto.)

4.  Como o tempo médio de atraso muda ao longo de um dia?
    Você deve usar `horario_saida` ou `sida_programada`?
    Por que?

5.  Em que dia da semana você deve sair se quiser minimizar a chance de atraso?

6.  O que torna a distribuição de `diamante$quilates` e `voos$saida_programada` semelhante?

7.  Confirme a nossa hipótese de que as saídas antecipadas dos voos nos minutos 20-30 e 50-60 são causadas por voos regulares que partem mais cedo.
    Dica: crie uma variável binária que informe se um voo atrasou ou não

## Períodos de tempo

A seguir, você aprenderá como funciona a aritmética com datas, incluindo subtração, adição e divisão.
Ao longo do caminho, você aprenderá sobre três classes importantes que representam intervalos de tempo:

-   **Duração** (*durations*), que representa um número exato de segundos.
-   **Períodos** (*periods*), que representam unidades como semanas e meses
-   **Intervalos** (*intervals*), que representam um ponto inicial e final.

Como você escolhe entre duração, períodos e intervalos?
Como sempre, escolha a estrutura de dados mais simples que resolva seu problema.
Se você se preocupa apenas com o tempo físico, use uma duração; se você precisar adicionar períodos de tempo, use um período; se você precisar descobrir quanto tempo dura um intervalo entre unidades, use um intervalo.

### Durações

No R, ao subtrair duas datas, você obtém um objeto de intervalo de tempo  da classe *difftime*:

```{r}
# Qual a idade do Hadley?
idade_hadley <- today() - ymd("1979-10-14")
idade_hadley
```

Um objeto de classe `difftime` registra um intervalo de tempo de segundos, minutos, horas, dias ou semanas.
Essa ambiguidade pode tornar os *difftimes* um pouco complicados de lidar, então o pacote lubridate fornece uma alternativa que sempre usa segundos: a **duração** (*duration*).

```{r}
as.duration(idade_hadley)
```

As durações vêm com vários construtores convenientes:

```{r}
dseconds(15)
dminutes(10)
dhours(c(12, 24))
ddays(0:5)
dweeks(3)
dyears(1)
```

As durações sempre registram o intervalo de tempo em segundos.
Unidades maiores são criadas convertendo minutos, horas, dias, semanas e anos em segundos: 60 segundos em um minuto, 60 minutos em uma hora, 24 horas em um dia e 7 dias em uma semana.
Unidades de tempo maiores são mais problemáticas.
Um ano usa o número "médio" de dias em um ano, ou seja, 365,25.
Não há como converter um mês em duração, porque há muita variação.

Você pode adicionar e multiplicar durações:

```{r}
2 * dyears(1)
dyears(1) + dweeks(12) + dhours(15)
```

Você pode adicionar e subtrair durações de e para dias:

```{r}
amanha <- today() + ddays(1)
ano_passado <- today() - dyears(1)
```

No entanto, como as durações representam um número exato de segundos, às vezes você pode obter um resultado inesperado:

```{r}
uma_da_manha <- ymd_hms("2026-03-08 01:00:00", tz = "America/New_York")

uma_da_manha
uma_da_manha + ddays(1)
```

Por que um dia depois da 1h é 8 de março e 2h é 9 de março?
Se você observar atentamente a data, também poderá notar que os fusos horários mudaram.
8 de março tem apenas 23 horas porque é quando começa o horário de verão, então, se adicionarmos um dia inteiro de segundos, teremos um horário diferente.

### Períodos

Para resolver esse problema, a lubridate fornece **períodos** (*periods*).
Os períodos são intervalos de tempo, mas não têm uma duração fixa em segundos; em vez disso, funcionam com tempos "humanos", como dias e meses.
Isso permite que funcionem de forma mais intuitiva:

```{r}
uma_da_manha
uma_da_manha + days(1)
```

Assim como as durações, os períodos podem ser criados com diversas funções construtoras amigáveis.

```{r}
hours(c(12, 24))
days(7)
months(1:6)
```

Você pode adicionar e multiplicar períodos:

```{r}
10 * (months(6) + days(1))
days(50) + hours(25) + minutes(2)
```

E, claro, adicione-os às datas.
Em comparação com as durações, os períodos têm maior probabilidade de fazer o que você espera:

```{r}
# Um ano bissexto
ymd("2024-01-01") + dyears(1)
ymd("2024-01-01") + years(1)

# Horario de verão
uma_da_manha + ddays(1)
uma_da_manha + days(1)
```

Vamos usar períodos para corrigir uma peculiaridade relacionada às datas dos nossos voos.
Alguns aviões parecem ter chegado ao seu destino *antes* de partirem da cidade de Nova York.

```{r}
voos_dt |> 
  filter(horario_chegada < horario_saida) 
```

São voos noturnos.
Usamos as mesmas informações de data para os horários de partida e chegada, mas esses voos chegaram no dia seguinte.
Podemos corrigir isso adicionando `days(1)` ao horário de chegada de cada voo noturno.

```{r}
voos_dt <- voos_dt |> 
  mutate(
    noturno = horario_chegada < horario_saida,
    horario_chegada = horario_chegada + days(noturno),
    chegada_prevista = chegada_prevista + days(noturno)
  )
```

Agora todos os nossos voos obedecem às leis da física.

```{r}
voos_dt |> 
  filter(horario_chegada < horario_saida) 
```

### Intervalos {#sec-intervals}

O que `dyears(1) / ddays(365)` retorna?
Não é exatamente 1, porque `dyears()` é definido como o número de segundos por ano de duração média, que é 365,25 dias.

O que `anos(1)/dias(1)` retorna?
Bom, se o ano fosse 2015 deveria retornar 365, mas se fosse 2016 deveria retornar 366!
Não há informações suficientes para o lubridate dar uma resposta única e clara.
Em vez disso, o que ele faz é fornecer uma estimativa:

```{r}
years(1) / days(1)
```

Se quiser uma medição mais precisa, você terá que usar um **intervalo** (*interval*).
Um intervalo é um par de datas iniciais e finais, ou você pode pensar nele como uma duração com um ponto inicial.

Você pode criar um intervalo escrevendo `start %--% end`:

```{r}
y2023 <- ymd("2023-01-01") %--% ymd("2024-01-01")
y2024 <- ymd("2024-01-01") %--% ymd("2025-01-01")

y2023
y2024
```

Você poderia então dividir por `days()` para descobrir quantos dias cabem no ano:

```{r}
y2023 / days(1)
y2024 / days(1)
```

### Exercícios

1.  Explique `days(!noturno)` e `days(noturno)` para alguém que acabou de começar a aprender R.
    Qual é o fato principal que você precisa saber?

2.  Crie um vetor de datas indicando o primeiro dia de cada mês de 2015.
    Crie um vetor de datas que forneça o primeiro dia de cada mês do ano *atual*.

3.  Escreva uma função que, dada a sua data de nascimento (como um objeto *date*), retorne quantos anos você tem em anos.

4.  Por que `(today() %--% (today() + years(1))) / months(1)` funciona?

## Fusos horários

Os fusos horários são um tema extremamente complicado devido à sua interação com entidades geopolíticas.
Felizmente, não precisamos nos aprofundar em todos os detalhes, pois nem todos são importantes para a análise de dados, mas existem alguns desafios que precisaremos enfrentar de frente.

<!--# https://www.ietf.org/timezones/tzdb-2018a/theory.html -->

O primeiro desafio é que os nomes cotidianos dos fusos horários tendem a ser ambíguos.
Por exemplo, se você é americano, provavelmente conhece EST, ou Eastern Standard Time.
No entanto, tanto a Austrália quanto o Canadá também têm EST!
Para evitar confusão, o R usa os fusos horários padrão internacional da IANA.
Eles usam um esquema de nomenclatura consistente `{area}/{local}`, normalmente na forma `{continent}/{cidade}` ou `{oceano}/{cidade}`.
Exemplos incluem "America/New_York", "Europe/Paris" e "Pacific/Auckland".

Você pode estar se perguntando por que o fuso horário usa uma cidade, quando normalmente você pensa nos fusos horários como associados a um país ou região dentro de um país.
Isso ocorre porque o banco de dados da IANA precisa registrar décadas de regras de fuso horário.
Ao longo das décadas, os países mudam de nome (ou se separam) com bastante frequência, mas os nomes das cidades tendem a permanecer os mesmos.
Outro problema é que o nome precisa refletir não apenas o comportamento atual, mas também o histórico completo.
Por exemplo, existem fusos horários para "America/New_York" e "America/Detroit".
Ambas as cidades usam atualmente o horário padrão do leste (EST), mas em 1969-1972 Michigan (o estado em que Detroit está localizada) não seguiu o horário de verão, por isso precisa de um nome diferente.
Vale a pena ler o banco de dados bruto de fuso horário (disponível em <https://www.iana.org/time-zones>) apenas para ler algumas dessas histórias!

Você pode descobrir qual fuso horário o R pensa que é o seu atual usando a função `Sys.timezone()`:

```{r}
Sys.timezone()
```

(Se o R não souber, você receberá um `NA`.)

E veja a lista completa de todos os nomes de fuso horário com `OlsonNames()`:

```{r}
length(OlsonNames())
head(OlsonNames())
```

No R, o fuso horário é um atributo de data e horário que controla apenas a impressão.
Por exemplo, estes três objetos representam o mesmo instante no tempo:

```{r}
x1 <- ymd_hms("2024-06-01 12:00:00", tz = "America/New_York")
x1

x2 <- ymd_hms("2024-06-01 18:00:00", tz = "Europe/Copenhagen")
x2

x3 <- ymd_hms("2024-06-02 04:00:00", tz = "Pacific/Auckland")
x3
```

Você pode verificar se eles são iguais usando subtração:

```{r}
x1 - x2
x1 - x3
```

A menos que especificado de outra forma, lubridate sempre usa UTC.
UTC (Tempo Universal Coordenado) é o fuso horário padrão usado pela comunidade científica e é aproximadamente equivalente ao GMT (Horário de Greenwich).
Não possui horário de verão, o que é uma representação conveniente para computação.
Operações que combinam data e horário, como `c()`, geralmente eliminam o fuso horário.
Nesse caso, as datas e horários serão exibidas no fuso horário do primeiro elemento:

```{r}
x4 <- c(x1, x2, x3)
x4
```

Você pode alterar o fuso horário de duas maneiras:

-   Mantendo o mesmo instante no tempo e alterando a forma como ele é exibido.
    Use isto quando o instante estiver correto, mas você quiser uma exibição mais natural.

    ```{r}
    x4a <- with_tz(x4, tzone = "Australia/Lord_Howe")
    x4a
    x4a - x4
    ```

    (Isso também ilustra outro desafio dos fusos horários: nem todos são deslocamentos de horas inteiras!)

-   Mudando o instante subjacente no tempo.
    Use isto quando você tiver um instante marcado com o fuso horário incorreto e precisar corrigi-lo.

    ```{r}
    x4b <- force_tz(x4, tzone = "Australia/Lord_Howe")
    x4b
    x4b - x4
    ```

## Resumo

Este capítulo apresentou as ferramentas que o pacote lubridate fornece para ajudá-lo a trabalhar com dados de data e horário.
Trabalhar com datas e horas pode parecer mais difícil do que o necessário, mas esperamos que este capítulo tenha ajudado você a ver por que --- datas e horários são mais complexos do que parecem à primeira vista, e lidar com todas as situações possíveis adiciona complexidade.
Mesmo que seus dados nunca ultrapassem o limite do horário de verão ou envolvam um ano bissexto, as funções precisam ser capazes de lidar com isso.

O próximo capítulo fornece um resumo dos valores ausentes (*missing values*).
Você já os viu em alguns lugares e sem dúvida os encontrou em sua própria análise, e agora é hora de fornecer um conjunto de técnicas úteis para lidar com eles.
