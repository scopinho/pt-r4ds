# Dates and times {#sec-dates-and-times}

```{r}
#| echo: false
#| results: asis
source("_common.R")
mensagem_capitulo_sem_traducao()

# https://github.com/tidyverse/lubridate/issues/1058
options(warnPartialMatchArgs = FALSE)
```

## Introduction


Este capítulo mostrará como trabalhar com datas e horários (*dates and times*) no R.
À primeira vista, datas e horários parecem simples.
Você os utiliza o tempo todo em sua vida e eles não parecem causar muita confusão.
Porém, quanto mais você aprende sobre datas e horários, mais complicados eles parecem ficar!

To warm up think about how many days there are in a year, and how many hours there are in a day.
You probably remembered that most years have 365 days, but leap years have 366.
Do you know the full rule for determining if a year is a leap year[^datetimes-1]?
The number of hours in a day is a little less obvious: most days have 24 hours, but in places that use daylight saving time (DST), one day each year has 23 hours and another has 25.

[^datetimes-1]: A year is a leap year if it's divisible by 4, unless it's also divisible by 100, except if it's also divisible by 400.
    In other words, in every set of 400 years, there's 97 leap years.

Datas e horários são difíceis porque têm de conciliar dois fenômenos físicos (a rotação da Terra e a sua órbita em torno do Sol) com uma série de fenômenos geopolíticos, incluindo meses, fusos horários e horário de verão.
Este capítulo não ensinará todos os detalhes sobre datas e horários, mas fornecerá uma base sólida de habilidades práticas que te ajudarão com desafios comuns de análise de dados.

We'll begin by showing you how to create date-times from various inputs, and then once you've got a date-time, how you can extract components like year, month, and day.
We'll then dive into the tricky topic of working with time spans, which come in a variety of flavors depending on what you're trying to do.
We'll conclude with a brief discussion of the additional challenges posed by time zones.

### Prerequisites

Este capítulo se concentrará no pacote **lubridate**, que facilita o trabalho com datas e horários no R.
Na versão mais recente do tidyverse, o lubridate passou a ser um pacote principal do tidyverse.
Para praticar, também precisaremos do conjunto de dados voos do pacote dados.

```{r}
#| message: false
library(tidyverse)
library(nycflights13)
```

## Creating date/times {#sec-creating-datetimes}

There are three types of date/time data that refer to an instant in time:

-   A **date**.
    Tibbles print this as `<date>`.

-   A **time** within a day.
    Tibbles print this as `<time>`.

-   A **date-time** is a date plus a time: it uniquely identifies an instant in time (typically to the nearest second).
    Tibbles print this as `<dttm>`.
    Base R calls these POSIXct, but doesn't exactly trip off the tongue.


Neste capítulo iremos nos concentrar nas classes data (*date*) e data-horário (*date-time*), já que o R não possui uma classe nativa para lidar apenas com horário (*time*).
Se você precisar de uma, pode usar o pacote **hms**.

You should always use the simplest possible data type that works for your needs.
That means if you can use a date instead of a date-time, you should.
Date-times are substantially more complicated because of the need to handle time zones, which we'll come back to at the end of the chapter.

To get the current date or date-time you can use `today()` or `now()`:

```{r}
today()
now()
```

Otherwise, the following sections describe the four ways you're likely to create a date/time:

-   While reading a file with readr.
-   From a string.
-   From individual date-time components.
-   From an existing date/time object.

### During import

If your CSV contains an ISO8601 date or date-time, you don't need to do anything; readr will automatically recognize it:

```{r}
#| message: false
csv <- "
  date,datetime
  2022-01-02,2022-01-02 05:12
"
read_csv(csv)
```

If you haven't heard of **ISO8601** before, it's an international standard[^datetimes-2] for writing dates where the components of a date are organized from biggest to smallest separated by `-`. For example, in ISO8601 May 3 2022 is `2022-05-03`. ISO8601 dates can also include times, where hour, minute, and second are separated by `:`, and the date and time components are separated by either a `T` or a space.
For example, you could write 4:26pm on May 3 2022 as either `2022-05-03 16:26` or `2022-05-03T16:26`.

[^datetimes-2]: <https://xkcd.com/1179/>


Para outros formatos de data e horário, você precisará usar `col_types` com `col_date()` ou `col_datetime()` junto com um formato de data e horário.
O formato de data e horário usado pelo pacote readr é um padrão usado em muitas linguagens de programação, descrevendo um componente de data com um `%` seguido por um único caractere.
Por exemplo, `%Y-%m-%d` especifica uma data que é um ano, `-`, mês (como número) `-`, dia.
A tabela @tbl-date-formats lista todas as opções.

| Type    | Code  | Meaning                             | Example         |
|---------|-------|-------------------------------------|-----------------|
| Ano     | `%Y`  | Ano com 4 digitos                    | 2021            |
|         | `%y`  | Ano com 2 digitos                    | 21              |
| Mês     | `%m`  | Número                              | 2               |
|         | `%b`  | Nome abreviado                      | Feb             |
|         | `%B`  | Nome completo                       | February        |
| Dia     | `%d`  | Um ou dois digitos                  | 2               |
|         | `%e`  | Dois digitos                        | 02              |
| Horário | `%H`  | Horas em 24-horas                   | 13              |
|         | `%I`  | Horas em 12-horas                   | 1               |
|         | `%p`  | AM/PM                               | pm              |
|         | `%M`  | Minutos                             | 35              |
|         | `%S`  | Segundos                            | 45              |
|         | `%OS` | Seconds com decimal                 | 45.35           |
|         | `%Z`  | Nome fuso horário                   | America/Chicago |
|         | `%z`  | Ajuste (*offset*) de UTC            | +0800           |
| Outras  | `%.`  | Pula um não digito                  | :               |
|         | `%*`  | Pula qualquer número de não digito  |                 |

: Todos os formatos de datas compreendidos pelo readr {#tbl-date-formats}

E este código mostra algumas opções aplicadas a uma data muito ambígua:


```{r}
#| messages: false

csv <- "
  date
  01/02/15
"

read_csv(csv, col_types = cols(date = col_date("%m/%d/%y")))

read_csv(csv, col_types = cols(date = col_date("%d/%m/%y")))

read_csv(csv, col_types = cols(date = col_date("%y/%m/%d")))
```


Observe que não importa como você especifica o formato da data, ela sempre será exibida da mesma maneira quando você o inserir no R.


If you're using `%b` or `%B` and working with non-English dates, you'll also need to provide a `locale()`.
See the list of built-in languages in `date_names_langs()`, or create your own with `date_names()`,

### From strings

A linguagem de especificação de data e horário é poderosa, mas requer uma análise cuidadosa do formato da data.
Uma abordagem alternativa é usar os auxiliares do pacote lubridate que tentam determinar automaticamente o formato assim que você especifica a ordem do componente.
Para usá-los, identifique a ordem em que ano (*year*), mês (*month*) e dia (*day*) aparecem em suas datas e organize "y", "m" e "d" na mesma ordem.
Isso lhe dá o nome da função lubridate que interpretará sua data.
Por exemplo:

```{r}
ymd("2017-01-31")
mdy("January 31st, 2017")
dmy("31-Jan-2017")
```

`ymd()` and friends create dates.
To create a date-time, add an underscore and one or more of "h", "m", and "s" to the name of the parsing function:

```{r}
ymd_hms("2017-01-31 20:11:59")
mdy_hm("01/31/2017 08:01")
```

You can also force the creation of a date-time from a date by supplying a timezone:

```{r}
ymd("2017-01-31", tz = "UTC")
```

Aqui eu uso o fuso horário UTC[^datetimes-3] que você também pode conhecer como GMT, ou Greenwich Mean Time, o horário em 0° de longitude[^datetimes-4]
. Ele não usa o horário de verão, o que torna os cálculos um pouco mais simples.


[^datetimes-3]: You might wonder what UTC stands for.
    It's a compromise between the English "Coordinated Universal Time" and French "Temps Universel Coordonné".

[^datetimes-4]: No prizes for guessing which country came up with the longitude system.

### From individual components

Instead of a single string, sometimes you'll have the individual components of the date-time spread across multiple columns.
This is what we have in the `flights` data:

```{r}
flights |> 
  select(year, month, day, hour, minute)
```

Para criar uma data/horário a partir deste tipo de entrada, use a função `make_date()` para datas, ou `make_datetime()` para data-horário:


```{r}
flights |> 
  select(year, month, day, hour, minute) |> 
  mutate(departure = make_datetime(year, month, day, hour, minute))
```


Vamos fazer a mesma coisa para cada uma das quatro colunas de tempo em `voos`.
Os horários são representados em um formato particular, por isso usamos a aritmética de módulo para extrair os componentes de hora e minuto.
Depois de criarmos as variáveis de data e horário, nos concentraremos nas variáveis que exploraremos no restante do capítulo.


```{r}
make_datetime_100 <- function(year, month, day, time) {
  make_datetime(year, month, day, time %/% 100, time %% 100)
}

flights_dt <- flights |> 
  filter(!is.na(dep_time), !is.na(arr_time)) |> 
  mutate(
    dep_time = make_datetime_100(year, month, day, dep_time),
    arr_time = make_datetime_100(year, month, day, arr_time),
    sched_dep_time = make_datetime_100(year, month, day, sched_dep_time),
    sched_arr_time = make_datetime_100(year, month, day, sched_arr_time)
  ) |> 
  select(origin, dest, ends_with("delay"), ends_with("time"))

flights_dt
```

With this data, we can visualize the distribution of departure times across the year:

```{r}
#| fig.alt: >
#|   Um gráfico de polígono de frequência com horário de saída (janeiro-dezembro de 2013) no eixo-x
#|   e número de voos no eixo-y (0-1000). O polígono de frequência
#|   é agrupado por dia para que você veja uma série temporal de voos por dia. O
#|   o padrão é dominado por um padrão semanal; há menos voos 
#|   nos fins de semana. São poucos os dias que se destacam por terem tido surpreendentemente
#|   poucos voos no início de fevereiro, início de julho, final de novembro e final de
#|   dezembro.
voos_dt |> 
  ggplot(aes(x = horario_saida)) + 
  geom_freqpoly(binwidth = 86400) # 86400 segundos = 1 dia
```

Or within a single day:

```{r}
#| fig.alt: >
#|   Um polígono de frequência com horário de partida (6h - meia-noite de 1º de janeiro) no
#|   eixo x, número de voos no eixo y (0-17), agrupados em incrementos de 10 minutos.
#|   É difícil ver muitos padrões devido à alta variabilidade,
#|   mas a maioria dos grupos tem de 8 a 12 voos, e há significativamente menos voos 
#|   antes das 6h e depois das 20h.
voos_dt |> 
  filter(horario_saida < ymd(20130102)) |> 
  ggplot(aes(x = horario_saida)) + 
  geom_freqpoly(binwidth = 600) # 600 s = 10 minutos
```

Note that when you use date-times in a numeric context (like in a histogram), 1 means 1 second, so a binwidth of 86400 means one day.
For dates, 1 means 1 day.

### From other types

Você pode querer alternar entre uma data e horário (*date-times*) e uma data (*date*).
Esse é o trabalho ds funções `as_datetime()` e `as_date()`:


```{r}
as_datetime(today())
as_date(now())
```

Às vezes, você obterá datas/horários como deslocamentos (*offsets*) numéricos a partir da "Era Unix" (*Unix Epoch*), 01/01/1970.
Se o deslocamento (*offset*) estiver em segundos, use `as_datetime()`; se for em dias, use `as_date()`.


```{r}
as_datetime(60 * 60 * 10)
as_date(365 * 10 + 2)
```

### Exercises

1.  What happens if you parse a string that contains invalid dates?

    ```{r}
    #| eval: false

    ymd(c("2010-10-10", "bananas"))
    ```


2.  O que o argumento `tzone` para a função `today()` faz?
    Por que ele é importante?

3.  For each of the following date-times, show how you'd parse it using a readr column specification and a lubridate function.

    ```{r}
    d1 <- "January 1, 2010"
    d2 <- "2015-Mar-07"
    d3 <- "06-Jun-2017"
    d4 <- c("August 19 (2015)", "July 1 (2015)")
    d5 <- "12/30/14" # Dec 30, 2014
    t1 <- "1705"
    t2 <- "11:15:10.12 PM"
    ```

## Date-time components

Agora que você sabe como inserir dados de data e horário (*date time*) nas estruturas de dados de data e horário do R, vamos explorar o que você pode fazer com eles.
Esta seção se concentrará nas funções que permitem obter e definir componentes individuais.
A próxima seção abordará como a aritmética funciona com datas e horários.


### Getting components

You can pull out individual parts of the date with the accessor functions `year()`, `month()`, `mday()` (day of the month), `yday()` (day of the year), `wday()` (day of the week), `hour()`, `minute()`, and `second()`.
These are effectively the opposites of `make_datetime()`.

```{r}
datetime <- ymd_hms("2026-07-08 12:34:56")

year(datetime)
month(datetime)
mday(datetime)

yday(datetime)
wday(datetime)
```

For `month()` and `wday()` you can set `label = TRUE` to return the abbreviated name of the month or day of the week.
Set `abbr = FALSE` to return the full name.

```{r}
month(datetime, label = TRUE)
wday(datetime, label = TRUE, abbr = FALSE)
```

We can use `wday()` to see that more flights depart during the week than on the weekend:

```{r}
#| fig-alt: |

#|   Um gráfico de barras com os dias da semana no eixo x e o número de 
#|   vôos no eixo y. De segunda a sexta-feira têm aproximadamente o mesmo número de
#|   voos, ~48.0000, diminuindo ligeiramente ao longo da semana.
#|   Domingo é um pouco menor (~45.000) e sábado é muito menor 
#|   (~38,000).
flights_dt |> 
  mutate(wday = wday(dep_time, label = TRUE)) |> 
  ggplot(aes(x = wday)) +
  geom_bar()
```

We can also look at the average departure delay by minute within the hour.
There's an interesting pattern: flights leaving in minutes 20-30 and 50-60 have much lower delays than the rest of the hour!

```{r}
#| fig-alt: | 
#|   Um gráfico de linhas com o minuto da saída real (0-60) no eixo x e
#|   atraso médio (4-20) no eixo y. O atraso médio começa em (0, 12),
#|   aumenta constantemente para (18, 20), depois cai drasticamente, atingindo o mínimo
#|   aproximadamente 23 minutos após a hora e 9 minutos de atraso. Então aumenta
#|   novamente para (17, 35) e diminui acentuadamente para (55, 4). Isso acaba
#|   com um aumento para (60, 9).
voos_dt |> 
  mutate(minuto = minute(horario_saida)) |> 
  group_by(minuto) |> 
  summarize(
    avg_delay = mean(dep_delay, na.rm = TRUE),
    n = n()
  ) |> 
  ggplot(aes(x = minute, y = avg_delay)) +
  geom_line()
```


Curiosamente, se olharmos para o horário de saída *programado*, não veremos um padrão tão forte:


```{r}
#| fig-alt: | 
#|   A line chart with minute of scheduled departure (0-60) on the x-axis
#|   and average delay (4-16). There is relatively little pattern, just a
#|   small suggestion that the average delay decreases from maybe 10 minutes
#|   to 8 minutes over the course of the hour.
sched_dep <- flights_dt |> 
  mutate(minute = minute(sched_dep_time)) |> 
  group_by(minute) |> 
  summarize(
    avg_delay = mean(arr_delay, na.rm = TRUE),
    n = n()
  )

ggplot(sched_dep, aes(x = minute, y = avg_delay)) +
  geom_line()
```

So why do we see that pattern with the actual departure times?
Well, like much data collected by humans, there's a strong bias towards flights leaving at "nice" departure times, as @fig-human-rounding shows.
Always be alert for this sort of pattern whenever you work with data that involves human judgement!

```{r}
#| label: fig-human-rounding
#| fig-cap: |
#|   A frequency polygon showing the number of flights scheduled to 
#|   depart each hour. You can see a strong preference for round numbers
#|   like 0 and 30 and generally for numbers that are a multiple of five.
#| fig-alt: |
#|   A line plot with departure minute (0-60) on the x-axis and number of
#|   flights (0-60000) on the y-axis. Most flights are scheduled to depart
#|   on either the hour (~60,000) or the half hour (~35,000). Otherwise,
#|   all most all flights are scheduled to depart on multiples of five, 
#|   with a few extra at 15, 45, and 55 minutes.
#| echo: false
ggplot(sched_dep, aes(x = minute, y = n)) +
  geom_line()
```

### Rounding

Uma abordagem alternativa para plotar componentes individuais é arredondar a data para uma unidade de tempo próxima, com `floor_date()`, `round_date()` e `ceiling_date()`.
Cada função tem como argumento um vetor de datas para ajustar e o nome da unidade de tempo para arredondar para baixo (*floor*), para cima (*ceiling*) ou para simplesmente arredondar para a data sem mover para cima ou para baixo.
Isto, por exemplo, permite-nos criar um gráfico com o número de voos por semana:

```{r}
#| fig-alt: |
#|   Um gráfico de linhas com a semana (janeiro-dezembro de 2013) no eixo x e o número de
#|   voos (2.000-7.000) no eixo y. O padrão é razoavelmente uniforme entre
#|   fevereiro e novembro, com cerca de 7.000 voos por semana. Há
#|   muito menos voos na primeira (aproximadamente 4.500 voos) e na última
#|   semanas do ano (aproximadamente 2.500 voos).
voos_dt |> 
  count(semana = floor_date(horario_saida, "week")) |> 
  ggplot(aes(x = semana, y = n)) +
  geom_line() + 
  geom_point()
```

Você pode usar o arredondamento para visualizar a distribuição de voos ao longo de um dia, calculando a diferença entre `horario_saida` e o primeiro instante daquele dia:

```{r}
#| fig-alt: |
#|   Um gráfico de linha com tempo de partida no eixo x. Isto é, unidades de segundos
#|   desde meia-noite, então é difícil de interpretar.
voos_dt |> 
  mutate(hora_saida = horario_saida - floor_date(horario_saida, "day")) |> 
  ggplot(aes(x = hora_saida)) +
  geom_freqpoly(binwidth = 60 * 30)
```

Calcular a diferença entre um par de variáveis data-horário produz um objeto *difftime* (mais sobre isso na @sec-intervals).
Podemos converter isso em um objeto `hms` para obter um eixo x mais útil:

```{r}
#| fig-alt: |
#|   Um gráfico de linha com horário de saída (meia-noite à meia-noite) no eixo x
#|   e número de voos no eixo-y (0 a 15.000). Há muito poucos
#|   (<100) voos antes das 5h. O número de voos aumenta rapidamente 
#|   para 12.000/hora, com pico de 15.000 às 9h, antes de cair para cerca de
#|   8.000 / hora das 10h às 14h. O número de voos aumenta então para
#|   cerca de 12.000 por hora até as 20h, quando voltam a cair rapidamente. 
voos_dt |> 
  mutate(hora_saida = hms::as_hms(horario_saida - floor_date(horario_saida, "day"))) |> 
  ggplot(aes(x = hora_saida)) +
  geom_freqpoly(binwidth = 60 * 30)
```

### Modifying components

Você também pode usar cada função de acesso para modificar os componentes de uma data/horário.
Isso não aparece muito na análise de dados, mas pode ser útil ao limpar dados que possuem datas que claramente estão incorretas.

```{r}
(datetime <- ymd_hms("2026-07-08 12:34:56"))

year(datetime) <- 2030
datetime
month(datetime) <- 01
datetime
hour(datetime) <- hour(datetime) + 1
datetime
```

Alternatively, rather than modifying an existing variable, you can create a new date-time with `update()`.
This also allows you to set multiple values in one step:

```{r}
update(datetime, year = 2030, month = 2, mday = 2, hour = 2)
```

If values are too big, they will roll-over:

```{r}
update(ymd("2023-02-01"), mday = 30)
update(ymd("2023-02-01"), hour = 400)
```

### Exercises

1.  How does the distribution of flight times within a day change over the course of the year?

2.  Compare `horario_saida`, `saida_programada` e `atraso_saida`.
    Eles são consistentes?
    Explique suas descobertas.

3.  Compare `air_time` with the duration between the departure and arrival.
    Explain your findings.
    (Hint: consider the location of the airport.)

4.  How does the average delay time change over the course of a day?
    Should you use `dep_time` or `sched_dep_time`?
    Why?

5.  On what day of the week should you leave if you want to minimise the chance of a delay?

6.  O que torna a distribuição de `diamante$quilates` e `voos$saida_programada` semelhante?

7.  Confirme a nossa hipótese de que as saídas antecipadas dos voos nos minutos 20-30 e 50-60 são causadas por voos regulares que partem mais cedo.
    Dica: crie uma variável binária que informe se um voo atrasou ou não

## Time spans


A seguir, você aprenderá como funciona a aritmética com datas, incluindo subtração, adição e divisão.
Ao longo do caminho, você aprenderá sobre três classes importantes que representam intervalos de tempo:

-   **Duração** (*durations*), que representa um número exato de segundos.
-   **Períodos** (*periods*), que representam unidades como semanas e meses
-   **Intervalos** (*intervals*), que representam um ponto inicial e final.

Como você escolhe entre duração, períodos e intervalos?
Como sempre, escolha a estrutura de dados mais simples que resolva seu problema.
Se você se preocupa apenas com o tempo físico, use uma duração; se você precisar adicionar períodos de tempo, use um período; se você precisar descobrir quanto tempo dura um intervalo entre unidades, use um intervalo.

### Durations


No R, ao subtrair duas datas, você obtém um objeto de intervalo de tempo da classe *difftime*:


```{r}
# How old is Hadley?
h_age <- today() - ymd("1979-10-14")
h_age
```


Um objeto de classe `difftime` registra um intervalo de tempo de segundos, minutos, horas, dias ou semanas.
Essa ambiguidade pode tornar os *difftimes* um pouco complicados de lidar, então o pacote lubridate fornece uma alternativa que sempre usa segundos: a **duração** (*duration*).


```{r}
as.duration(h_age)
```

Durations come with a bunch of convenient constructors:

```{r}
dseconds(15)
dminutes(10)
dhours(c(12, 24))
ddays(0:5)
dweeks(3)
dyears(1)
```

Durations always record the time span in seconds.
Larger units are created by converting minutes, hours, days, weeks, and years to seconds: 60 seconds in a minute, 60 minutes in an hour, 24 hours in a day, and 7 days in a week.
Larger time units are more problematic.
A year uses the "average" number of days in a year, i.e. 365.25.
There's no way to convert a month to a duration, because there's just too much variation.

You can add and multiply durations:

```{r}
2 * dyears(1)
dyears(1) + dweeks(12) + dhours(15)
```

You can add and subtract durations to and from days:

```{r}
tomorrow <- today() + ddays(1)
last_year <- today() - dyears(1)
```

However, because durations represent an exact number of seconds, sometimes you might get an unexpected result:

```{r}
one_am <- ymd_hms("2026-03-08 01:00:00", tz = "America/New_York")

one_am
one_am + ddays(1)
```

Why is one day after 1am March 8, 2am March 9?
If you look carefully at the date you might also notice that the time zones have changed.
March 8 only has 23 hours because it's when DST starts, so if we add a full days worth of seconds we end up with a different time.

### Periods

Para resolver esse problema, a lubridate fornece **períodos** (*periods*).
Os períodos são intervalos de tempo, mas não têm uma duração fixa em segundos; em vez disso, funcionam com tempos "humanos", como dias e meses.
Isso permite que funcionem de forma mais intuitiva:


```{r}
one_am
one_am + days(1)
```

Like durations, periods can be created with a number of friendly constructor functions.

```{r}
hours(c(12, 24))
days(7)
months(1:6)
```

You can add and multiply periods:

```{r}
10 * (months(6) + days(1))
days(50) + hours(25) + minutes(2)
```

And of course, add them to dates.
Compared to durations, periods are more likely to do what you expect:

```{r}
# A leap year
ymd("2024-01-01") + dyears(1)
ymd("2024-01-01") + years(1)

# Daylight saving time
one_am + ddays(1)
one_am + days(1)
```


Vamos usar períodos para corrigir uma peculiaridade relacionada às datas dos nossos voos.
Alguns aviões parecem ter chegado ao seu destino *antes* de partirem da cidade de Nova York.


```{r}
flights_dt |> 
  filter(arr_time < dep_time) 
```

These are overnight flights.
We used the same date information for both the departure and the arrival times, but these flights arrived on the following day.
We can fix this by adding `days(1)` to the arrival time of each overnight flight.

```{r}
flights_dt <- flights_dt |> 
  mutate(
    overnight = arr_time < dep_time,
    arr_time = arr_time + days(overnight),
    sched_arr_time = sched_arr_time + days(overnight)
  )
```

Now all of our flights obey the laws of physics.

```{r}
flights_dt |> 
  filter(arr_time < dep_time) 
```

### Intervals {#sec-intervals}


O que `dyears(1) / ddays(365)` retorna?
Não é exatamente 1, porque `dyears()` é definido como o número de segundos por ano de duração média, que é 365,25 dias.

O que `anos(1)/dias(1)` retorna?
Bom, se o ano fosse 2015 deveria retornar 365, mas se fosse 2016 deveria retornar 366!
Não há informações suficientes para o lubridate dar uma resposta única e clara.
Em vez disso, o que ele faz é fornecer uma estimativa:


```{r}
years(1) / days(1)
```

If you want a more accurate measurement, you'll have to use an **interval**.
An interval is a pair of starting and ending date times, or you can think of it as a duration with a starting point.

You can create an interval by writing `start %--% end`:

```{r}
y2023 <- ymd("2023-01-01") %--% ymd("2024-01-01")
y2024 <- ymd("2024-01-01") %--% ymd("2025-01-01")

y2023
y2024
```

You could then divide it by `days()` to find out how many days fit in the year:

```{r}
y2023 / days(1)
y2024 / days(1)
```

### Exercises

1.  Explain `days(!overnight)` and `days(overnight)` to someone who has just started learning R.
    What is the key fact you need to know?

2.  Create a vector of dates giving the first day of every month in 2015.
    Create a vector of dates giving the first day of every month in the *current* year.


3.  Escreva uma função que, dada a sua data de nascimento (como um objeto *date*), retorne quantos anos você tem em anos.


4.  Why can't `(today() %--% (today() + years(1))) / months(1)` work?


## Fusos horários


Time zones are an enormously complicated topic because of their interaction with geopolitical entities.
Fortunately we don't need to dig into all the details as they're not all important for data analysis, but there are a few challenges we'll need to tackle head on.

<!--# https://www.ietf.org/timezones/tzdb-2018a/theory.html -->


O primeiro desafio é que os nomes cotidianos dos fusos horários tendem a ser ambíguos.
Por exemplo, se você é americano, provavelmente conhece EST, ou Eastern Standard Time.
No entanto, tanto a Austrália quanto o Canadá também têm EST!
Para evitar confusão, o R usa os fusos horários padrão internacional da IANA.
Eles usam um esquema de nomenclatura consistente `{area}/{local}`, normalmente na forma `{continent}/{cidade}` ou `{oceano}/{cidade}`.
Exemplos incluem "America/New_York", "Europe/Paris" e "Pacific/Auckland".

Você pode estar se perguntando por que o fuso horário usa uma cidade, quando normalmente você pensa nos fusos horários como associados a um país ou região dentro de um país.
Isso ocorre porque o banco de dados da IANA precisa registrar décadas de regras de fuso horário.
Ao longo das décadas, os países mudam de nome (ou se separam) com bastante frequência, mas os nomes das cidades tendem a permanecer os mesmos.
Outro problema é que o nome precisa refletir não apenas o comportamento atual, mas também o histórico completo.
Por exemplo, existem fusos horários para "America/New_York" e "America/Detroit".
Ambas as cidades usam atualmente o horário padrão do leste (EST), mas em 1969-1972 Michigan (o estado em que Detroit está localizada) não seguiu o horário de verão, por isso precisa de um nome diferente.
Vale a pena ler o banco de dados bruto de fuso horário (disponível em <https://www.iana.org/time-zones>) apenas para ler algumas dessas histórias!

Você pode descobrir qual fuso horário o R pensa que é o seu atual usando a função `Sys.timezone()`:

```{r}
Sys.timezone()
```


(Se o R não souber, você receberá um `NA`.)


And see the complete list of all time zone names with `OlsonNames()`:

```{r}
length(OlsonNames())
head(OlsonNames())
```

In R, the time zone is an attribute of the date-time that only controls printing.
For example, these three objects represent the same instant in time:

```{r}
x1 <- ymd_hms("2024-06-01 12:00:00", tz = "America/New_York")
x1

x2 <- ymd_hms("2024-06-01 18:00:00", tz = "Europe/Copenhagen")
x2

x3 <- ymd_hms("2024-06-02 04:00:00", tz = "Pacific/Auckland")
x3
```

You can verify that they're the same time using subtraction:

```{r}
x1 - x2
x1 - x3
```

Unless otherwise specified, lubridate always uses UTC.
UTC (Coordinated Universal Time) is the standard time zone used by the scientific community and is roughly equivalent to GMT (Greenwich Mean Time).
It does not have DST, which makes a convenient representation for computation.
Operations that combine date-times, like `c()`, will often drop the time zone.
In that case, the date-times will display in the time zone of the first element:

```{r}
x4 <- c(x1, x2, x3)
x4
```

You can change the time zone in two ways:

-   Keep the instant in time the same, and change how it's displayed.
    Use this when the instant is correct, but you want a more natural display.

    ```{r}
    x4a <- with_tz(x4, tzone = "Australia/Lord_Howe")
    x4a
    x4a - x4
    ```


    (Isso também ilustra outro desafio dos fusos horários: nem todos são deslocamentos de horas inteiras!)


-   Change the underlying instant in time.
    Use this when you have an instant that has been labelled with the incorrect time zone, and you need to fix it.

    ```{r}
    x4b <- force_tz(x4, tzone = "Australia/Lord_Howe")
    x4b
    x4b - x4
    ```

## Summary

This chapter has introduced you to the tools that lubridate provides to help you work with date-time data.
Working with dates and times can seem harder than necessary, but hopefully this chapter has helped you see why --- date-times are more complex than they seem at first glance, and handling every possible situation adds complexity.
Even if your data never crosses a day light savings boundary or involves a leap year, the functions need to be able to handle it.

The next chapter gives a round up of missing values.
You've seen them in a few places and have no doubt encounter in your own analysis, and it's now time to provide a grab bag of useful techniques for dealing with them.
